# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ZI_GTC
                                 A QGIS plugin
 Calcul Poblacio Afectada
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-11-14
        git sha              : $Format:%H$
        copyright            : (C) 2018 by CCU
        email                : jlopez@tecnocampus.cat
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import processing
from PyQt5.QtCore import * #QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtGui import * #QIcon
from PyQt5 import QtCore
from PyQt5.QtWidgets import QAction,QMessageBox, QApplication,QSizePolicy,QGridLayout,QDialogButtonBox,QFileDialog,QProgressBar,QColorDialog,QToolBar
from .ZI_GTC_dialog import ZI_GTCDialog
from qgis.core import QgsMapLayer,QgsWkbTypes
from qgis.core import QgsDataSourceUri
from qgis.core import QgsVectorLayer
from qgis.core import QgsVectorFileWriter
from qgis.core import QgsGraduatedSymbolRenderer
from qgis.core import QgsGradientColorRamp
from qgis.core import QgsProject
from qgis.core import QgsFillSymbol
from qgis.core import QgsRenderContext
from qgis.core import QgsRendererRangeLabelFormat
from qgis.core import QgsProject
from qgis.core import QgsLayerTreeLayer
from qgis.core import QgsFeature
from qgis.core import QgsGeometry
from qgis.core import QgsCoordinateTransform
from qgis.core import QgsField
from qgis.core import QgsPointXY
from qgis.utils import iface
import qgis.utils
#from PyQt5.QtGui import QProgressBar
from qgis.core import Qgis,QgsCoordinateReferenceSystem,QgsVectorLayerExporter
from qgis.gui import QgsMessageBar
from PyQt5.QtSql import *
from PyQt5.QtCore import *
from .resources import *
from os.path import expanduser
import datetime
import time
#import qgis
# Initialize Qt resources from file resources.py
#import resources
# Import the code for the dialog
from .ZI_GTC_dialog import ZI_GTCDialog
import psycopg2
import os.path
#from macpath import curdir
import collections
import requests
import json
"""
Variables globals per a la connexio
i per guardar el color dels botons
"""
micolor=None
micolorArea = None
nomBD1=""
contra1=""
host1=""
port1=""
usuari1=""
schema=""
entitat_poi=""
Fitxer=""
Path_Inicial=expanduser("~")
cur=None
conn=None
progress=None
Versio_modul="V_Q3.241218"
connexioFeta = False
geometria=""
TEMPORARY_PATH=""
tipus_entitat_punt=False
versio_db = ""

valhalla_base_url = "https://ccuserver.tecnocampus.cat/routing/"

class ZI_GTC:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ZI_GTC_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        """
        Connexio dels botons amb les funcions que han de realitzar
        """
        self.dlg = ZI_GTCDialog()
        self.dlg.bt_cancelar.clicked.connect(self.on_click_Cancelar)
        self.dlg.bt_OK.clicked.connect(self.on_click_OK)
        self.dlg.comboMetodeTreball_CCU.currentIndexChanged.connect(self.changeComboMetodeTreball_CCU)
        self.dlg.comboMetodeTreball_Valhalla.currentIndexChanged.connect(self.changeComboMetodeTreball_Valhalla)
        self.dlg.color.clicked.connect(self.on_click_Color)
        self.dlg.color_2.clicked.connect(self.on_click_ColorArea)
        self.dlg.colorArea.clicked.connect(self.on_click_ColorArea)
        self.dlg.checkBoxDibuix.stateChanged.connect(self.on_click_cbDibuix)
        self.dlg.comboConnexio.currentIndexChanged.connect(self.on_Change_ComboConn)
        self.dlg.bt_ILLES.toggled.connect(self.on_click_MarcarIlles)
        self.dlg.bt_Parcel.toggled.connect(self.on_click_MarcarParcel)
        self.dlg.bt_Portals.toggled.connect(self.on_click_MarcarPortals)
        self.dlg.comboSelPunts.currentIndexChanged.connect(self.on_Change_ComboSelPunts)
        self.dlg.comboGraf.currentIndexChanged.connect(self.on_Change_ComboGraf)
        self.dlg.chk_poblacio.stateChanged.connect(self.on_click_CB_poblacio)
        self.dlg.RB_campFix.toggled.connect(self.on_click_campFix)
        self.dlg.RB_campTaula.toggled.connect(self.on_click_campTaula)
        self.dlg.RB_Graf.toggled.connect(self.on_click_Graf)
        self.dlg.RB_RadiCirc.toggled.connect(self.on_click_RadiCirc)
        self.dlg.comboLeyenda.currentIndexChanged.connect(self.on_Change_ComboLeyenda)
        self.dlg.comboConnexio.currentIndexChanged.connect(self.on_Change_ComboConn)
        self.dlg.bt_ReloadLeyenda.clicked.connect(self.cerca_elements_Leyenda)
        self.dlg.tabWidget_Destino.currentChanged.connect(self.on_Change_TabWidget)
        self.dlg.tabServeiRouting.currentChanged.connect(self.on_Change_TabServeiRouting)
        # Declare instance attributes
        self.actions = []
        self.menu = self.tr('&CCU')
        # TODO: We are going to let the user set this up in a future iteration
        #self.toolbar = self.iface.addToolBar('CCU')
        #self.toolbar.setObjectName('Calcul de Poblacio Afectada')
        trobat=False
        for x in iface.mainWindow().findChildren(QToolBar,'CCU'): 
            self.toolbar = x
            trobat=True
        
        if not trobat:
            self.toolbar = self.iface.addToolBar('CCU')
            self.toolbar.setObjectName('CCU')
        
        self.bar = QgsMessageBar()
        self.bar.setSizePolicy( QSizePolicy.Minimum, QSizePolicy.Fixed )
        self.dlg.setLayout(QGridLayout())
        self.dlg.layout().setContentsMargins(0, 0, 0, 0)
        self.dlg.buttonbox = QDialogButtonBox(QDialogButtonBox.Ok)
        self.dlg.buttonbox.accepted.connect(self.run)
        self.dlg.buttonbox.setVisible(False)
        self.dlg.layout().addWidget(self.dlg.buttonbox, 0, 0, 2, 1)
        self.dlg.layout().addWidget(self.bar, 0, 0,1,1)
        #self.dlg.bt_ReloadLeyenda.setIcon(QtGui.QIcon('D:\Eclipse\QGISV3\ZI_GTC\reloadIcon.png'))
        #self.dlg.bt_ReloadLeyenda.setIconSize(QtCore.QSize(16,16))

        self.dlg.rejected.connect(self.on_click_Cancelar)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ZI_GTC', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/ZI_GTC/icon.png'
        self.add_action(
            icon_path,
            text=self.tr('ZI-POB'),
            callback=self.run,
            parent=self.iface.mainWindow())


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr('&CCU'),
                action)
            #self.iface.removeToolBarIcon(action)
            self.toolbar.removeAction(action)
        # remove the toolbar
        #del self.toolbar

    def on_click_Graf(self,enabled):
        global tipus_entitat_punt
        tipus_entitat_punt=True
        self.dlg.groupBox_2.setVisible(tipus_entitat_punt)
        self.dlg.groupBox_Graf.setVisible(tipus_entitat_punt)
        self.dlg.groupBox_Graf_Valhalla.setVisible(tipus_entitat_punt)
        self.dlg.groupBox_4.setVisible(tipus_entitat_punt)
        self.dlg.groupBox_Circular.setVisible(not(tipus_entitat_punt))
        self.dlg.tabServeiRouting.setTabEnabled(1, tipus_entitat_punt)
        
    def on_click_RadiCirc(self,enabled):
        global tipus_entitat_punt
        tipus_entitat_punt=False
        self.dlg.groupBox_2.setVisible(tipus_entitat_punt)
        self.dlg.groupBox_Graf.setVisible(tipus_entitat_punt)
        self.dlg.groupBox_Graf_Valhalla.setVisible(tipus_entitat_punt)
        self.dlg.groupBox_4.setVisible(tipus_entitat_punt)
        self.dlg.groupBox_Circular.setVisible(not(tipus_entitat_punt))
        self.dlg.tabServeiRouting.setCurrentIndex(0)
        self.dlg.tabServeiRouting.setTabEnabled(1, tipus_entitat_punt)

    def on_click_campTaula(self,enabled):
        """Aquesta funci� activa o desactiva el camp de la taula"""
        if enabled:
            self.dlg.comboCapaPunts_CCU.setEnabled(True)
        else:
            self.dlg.comboCapaPunts_CCU.setEnabled(False)
            
    def on_click_campFix(self,enabled):
        """Aquesta funci� activa o desactiva el camp fix"""
        if enabled:
            self.dlg.TL_Dist_Cost_CCU.setEnabled(True)
        else:
            self.dlg.TL_Dist_Cost_CCU.setEnabled(False)
        
    def grafValid(self, taula):
        """Aquesta funci� comprova si la taula que li hem passat t� la seva capa de graf corresponent"""
        nom = self.dlg.comboGraf.currentText()
        global cur
        global conn
        if taula != 'stretch':
            sql = "select exists (select 1 from geometry_columns where f_table_name = '" + taula + "_vertices_pgr')"
        else:
            sql = "select exists (select 1 from geometry_columns where f_table_name = '" + taula + f"_{Fitxer}_vertices_pgr')"
        cur.execute(sql)
        camp = cur.fetchall()
        return camp[0][0]
        
    def controlErrors(self):
        """Aquesta funci� controla que tots els camps siguin correctes abans de fer el c�lcul"""
        global tipus_entitat_punt
        errors = []
        capa = None
        if self.dlg.comboConnexio.currentText() == 'Selecciona connexió':
            errors.append('No hi ha seleccionada cap connexió')
            
        if self.dlg.tabWidget_Destino.currentIndex() == 0: #Base de dades
            if self.dlg.comboSelPunts.currentText() == 'Selecciona una entitat':
                errors.append('No hi ha cap capa de destí seleccionada')
            elif self.dlg.comboSelPunts.currentText() == '':
                errors.append('No hi ha cap capa de destí disponible')
            else:
                capa = self.dlg.comboSelPunts.currentText()
        else:# Llegenda
            if self.dlg.comboLeyenda.currentText() == 'Selecciona una entitat':
                errors.append('No hi ha cap capa de destí seleccionada')
            elif self.dlg.comboLeyenda.currentText() == '':
                errors.append('No hi ha cap capa de destí disponible')
            else:
                capa = self.dlg.comboLeyenda.currentText()

        if (self.dlg.tabServeiRouting.currentIndex() == 0) and (self.dlg.comboGraf.currentText() == 'Selecciona una entitat' and tipus_entitat_punt):
            errors.append('No hi ha cap capa de xarxa seleccionada')
            #print(tipus_entitat_punt)
        if self.dlg.RB_campTaula.isChecked():
            if self.dlg.comboCapaPunts_CCU.currentText() == 'Selecciona un camp' or self.dlg.comboCapaPunts_CCU.currentText() == '':
                errors.append('No hi ha seleccionada cap camp seleccionat')
        if self.dlg.RB_campFix.isChecked():
            try:
                numero = float(self.dlg.TL_Dist_Cost_CCU.text())
                if numero < 0:
                    errors.append('El número fix del métode de treball no pot ser negatiu')
            except:
                errors.append('El número fix del métode de treball no és vàlid')
            
        try:
            numero2 = float(self.dlg.TL_radiZI.text())
            if numero2 < 0:
                errors.append('El número del radi de ZI no pot ser negatiu')
        except:
            errors.append('El número del radi de ZI no és vàlid')
        
        
        if self.dlg.TB_titol.text() == '':
            errors.append('No hi ha cap títol seleccionat')
          
        if capa is not None:
            if self.dlg.tabWidget_Destino.currentIndex() == 0:
                errorsCapa = self.controlEntitatSelPunts(capa) #retorna una llista amb aquells camps (id, geom, Nom) que no hi siguin.    
            else:
                errorsCapa = self.controlEntitatLeyenda(capa)
            print(errorsCapa)
            if len(errorsCapa) < 1:  # errors es una llista amb els camps que te la taula, si hi ha menys de 2, significa que falta algun camp.
                errors.append('La capa de destí no és vàlida')
        
        return errors
    
    def calcul_graf(self,sql_buff):
        """Fa servir el PGROUTING de POSTGRESQL per fer el routing. Aquesta es una funcio auxiliar que retorna un sql amb el buffer"""
        global cur
        global conn
        global micolor_Topo
        global micolor_ZI
        global micolor_Graf
        global Fitxer
        global progress
        global geometria
        print("servidor")
#       *****************************************************************************************************************
#       INICI CREACIO DE LA TAULA 'XARXA_GRAF' I PREPARACIO DELS CAMPS COST I REVERSE_COST
#       *****************************************************************************************************************
        #XarxaCarrers = self.dlg.comboGraf.currentText()
        XarxaCarrers = f'stretch_{Fitxer}'
        sql_1="DROP TABLE IF EXISTS \"Xarxa_Graf\";\n"
        """ Es fa una copia de la taula que cont� el graf i s'afegeixen els camps cost i reverse_cost en funci� del que es necessiti, es crear� taula local temporal per evitar problemes de concurrencia"""
        sql_1+="CREATE local temporary TABLE \"Xarxa_Graf\" as (SELECT * FROM \"" + XarxaCarrers + "\");\n"
        if (self.dlg.comboMetodeTreball_CCU.currentText()=="Distancia"):
            """S'aplica com a cost tant directe com invers el valor de la longitud del segment"""
            sql_1+="UPDATE \"Xarxa_Graf\" set \"cost\"=st_length(\"geom\"), \"reverse_cost\"=st_length(\"geom\");\n"
        else:
            if (not(self.dlg.checkReverse.isChecked())):
                """S'aplica com a 'cost' el valor del camp 'cost directe', i a 'reverse_cost' el valor del camp 'cost_invers"""
                sql_1+="UPDATE \"Xarxa_Graf\" set \"reverse_cost\"=\"cost\",\"cost\"=\"reverse_cost\";\n"

            if (self.dlg.chk_CostInvers_CCU.isChecked()):
                """S'aplica com a 'cost' el valor del camp 'cost directe', i a 'reverse_cost' el valor del camp 'cost_invers"""
                #sql_1+="UPDATE \"Xarxa_Graf\" set \"cost\"=\"Cost_Directe\", \"reverse_cost\"=\"Cost_Invers\";\n"
            else:
                """S'aplica com a 'cost' i 'reverse_cost' el valor del camp 'cost directe'"""
                sql_1+="UPDATE \"Xarxa_Graf\" set \"reverse_cost\"=\"cost\";\n"
                #sql_1+="UPDATE \"Xarxa_Graf\" set \"cost\"=\"Cost_Directe\", \"reverse_cost\"=\"Cost_Directe\";\n"
            if (self.dlg.chk_CostNusos_CCU.isChecked()):
                """Es suma al camp 'cost' i a 'reverse_cost' el valor dels semafors sempre i quan estigui la opci� marcada"""
                sql_1+="UPDATE \"Xarxa_Graf\" set \"cost\"=\"cost\"+(\"total_cost_semaphore\"), \"reverse_cost\"=\"reverse_cost\"+(\"total_cost_semaphore\");\n"
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("Error CREATE Xarxa_Graf")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error CREATE Xarxa_Graf")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()
            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
            return "ERROR"
#       *****************************************************************************************************************
#       FI CREACIO DE LA TAULA 'XARXA_GRAF' I PREPARACIO DELS CAMPS COST I REVERSE_COST
#       *****************************************************************************************************************

#       *****************************************************************************************************************
#       INICI CREACIO DE LA TAULA 'PUNTS_INTERES_TMP' QUE CONTINDRA ELS PUNTS D'INTERES PROJECTATS SOBRE EL TRAM
#       *****************************************************************************************************************        
        try:
            if self.dlg.tabWidget_Destino.currentIndex() == 0:
                geometria=self.campGeometria(self.dlg.comboSelPunts.currentText())
            else:
                #geometria=self.campGeometria(self.dlg.comboLeyenda.currentText())
                geometria=self.campGeometria("LayerExportat"+Fitxer)
            sql_1="drop table if exists punts_interes_tmp;\n"
            if self.dlg.RB_campTaula.isChecked():
                """Es crea la taula 'punts_interes_tmp' seleccionant el centroide de la entitat seleccionada utilitzant com a radi el valor del camp seleccionat"""
                sql_1+="CREATE local temporary TABLE punts_interes_tmp as (SELECT ST_Centroid(tmp.\""+geometria+"\") geom,tmp.\"id\"as pid,tmp.\""+str(self.dlg.comboCapaPunts_CCU.currentText())+"\" from ("+sql_buff+") tmp);\n"
            else:
                """Es crea la taula punts_interes_tmp seleccionant el centroide de la entitat seleccionada, utilizant un radi fix"""
                sql_1+="CREATE local temporary TABLE punts_interes_tmp as (SELECT ST_Centroid(tmp.\""+geometria+"\") geom,tmp.\"id\" as pid from ("+sql_buff+") tmp);\n"
                
            #sql_1+="ALTER TABLE punts_interes_tmp ADD COLUMN pid BIGSERIAL PRIMARY KEY;\n"
            sql_1+="ALTER TABLE punts_interes_tmp ADD COLUMN     x FLOAT;\n"
            sql_1+="ALTER TABLE punts_interes_tmp ADD COLUMN     y FLOAT;\n"
            sql_1+="ALTER TABLE punts_interes_tmp ADD COLUMN     edge_id BIGINT;\n"
            sql_1+="ALTER TABLE punts_interes_tmp ADD COLUMN     side CHAR;\n"
            sql_1+="ALTER TABLE punts_interes_tmp ADD COLUMN     fraction FLOAT;\n"
            sql_1+="ALTER TABLE punts_interes_tmp ADD COLUMN     newPoint geometry;\n"
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("Error CREATE punts_interes_tmp")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error CREATE punts_interes_tmp")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()
            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
            return "ERROR"
#       *****************************************************************************************************************
#       FI CREACIO DE LA TAULA 'PUNTS_INTERES_TMP' QUE CONTINDRA ELS PUNTS D'INTERES PROJECTATS SOBRE EL TRAM
#       *****************************************************************************************************************

#       *****************************************************************************************************************
#       INICI ASSIGNACIO DEL VALOR DEL TRAM MES PROPER AL CAMP 'EDGE_ID' DE LA TAULA 'PUNTS_INTERES_TMP I LA PROJECCIO DEL PUNT D'INTERES SOBRE EL TRAM
#       *****************************************************************************************************************
        """S'assigna el valor del tram més proper al punt d'interes en el camp 'edge_id' de la taula 'punts_interes_tmp'"""
        sql_1="UPDATE \"punts_interes_tmp\" set \"edge_id\"=tram_proper.\"tram_id\" from (SELECT distinct on(Poi.pid) Poi.pid As Punt_id,Sg.id as Tram_id, ST_Distance(Sg.geom,Poi.geom)  as dist FROM \"Xarxa_Graf\" as Sg,\"punts_interes_tmp\" AS Poi ORDER BY  Poi.pid,ST_Distance(Sg.geom,Poi.geom),Sg.id) tram_proper where \"punts_interes_tmp\".\"pid\"=tram_proper.\"punt_id\";\n"
        """Es calcula la fraccio del tram que on esta situat la projecci� del punt d'interes"""
        sql_1+="UPDATE \"punts_interes_tmp\" SET fraction = ST_LineLocatePoint(e.geom, \"punts_interes_tmp\".geom),newPoint = ST_LineInterpolatePoint(e.geom, ST_LineLocatePoint(e.geom, \"punts_interes_tmp\".geom)) FROM \"Xarxa_Graf\" AS e WHERE \"punts_interes_tmp\".\"edge_id\" = e.id;\n"
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("Error UPDATE punts_interes_temp")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error UPDATE punts_interes_temp")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()
            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
            return "ERROR"
#       *****************************************************************************************************************
#       FI ASSIGNACIO DEL VALOR DEL TRAM MES PROPER AL CAMP 'EDGE_ID' DE LA TAULA 'PUNTS_INTERES_TMP 
#       *****************************************************************************************************************

#       *****************************************************************************************************************
#       INICI DE LA CREACIO DE LA TAULA 'TBL_PUNTS_FINALS_TMP' QUE CONTINDRA ELS ID DELS NODES DE LA XARXA QUE SON A DINS DEL RADI 
#       *****************************************************************************************************************
        sql_1="DROP FUNCTION IF EXISTS Cobertura();\n"
        sql_1+="DROP TABLE IF EXISTS tbl_punts_finals_tmp;\n"
        if self.dlg.RB_campTaula.isChecked():
            """ Es posa a dins d'una variable 'Radi_Variable' tots els valors de radis de cada punt d'interes"""
            try:
                cur.execute("select \"pid\",\""+str(self.dlg.comboCapaPunts_CCU.currentText())+"\" from \"punts_interes_tmp\" order by \"pid\" asc ;\n")
                Radi_Variable = cur.fetchall()
            except Exception as ex:
                print ("Error SELECT punts_interes_tmp")
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", "Error SELECT punts_interes_tmp")
                conn.rollback()
                self.eliminaTaulesCalcul(Fitxer)
                self.eliminaTaulesTemporals()
                self.bar.clearWidgets()
                self.dlg.Progres.setValue(0)
                self.dlg.Progres.setVisible(False)
                self.dlg.lblEstatConn.setText('Connectat')
                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                return "ERROR"
            """Creaci� de la taula 'tbl_punts_finsl_tmp' on es tindr� tots els nodes de la xarxa que son a dins del radi d'acci� indicat fent UNION per cada entitat amb el seu radi personalitzat segons el valor del camp escollit"""
            sql_1+="CREATE local temporary TABLE tbl_punts_finals_tmp AS("
            for x in range (0,len(Radi_Variable)):
                if (x!=0):
                    sql_1+=" UNION "
                sql_1+="SELECT node,agg_cost,start_vid,"+str(Radi_Variable[x][1])+" as init_radi FROM pgr_withPointsDD('SELECT id, source, target, cost, reverse_cost FROM \"Xarxa_Graf\" ORDER BY id','SELECT pid, edge_id, fraction, side from \"punts_interes_tmp\"',array[-"+str(Radi_Variable[x][0])+"],"+str(Radi_Variable[x][1])+",driving_side := 'b',details := false)"
            sql_1+=");\n"
            
        else:
            """Creació de la taula 'tbl_punts_finsl_tmp' on es tindrà tots els nodes de la xarxa que son a dins del radi fix d'acci� indicat"""
            sql_1+="CREATE local temporary TABLE tbl_punts_finals_tmp AS(SELECT node,agg_cost,start_vid FROM pgr_withPointsDD('SELECT id, source, target, cost, reverse_cost FROM \"Xarxa_Graf\" ORDER BY \"Xarxa_Graf\".id','SELECT pid, edge_id, fraction, side from \"punts_interes_tmp\"',array(select \"pid\"*(-1) from \"punts_interes_tmp\"),"+self.dlg.TL_Dist_Cost_CCU.text()+",driving_side := 'b',details := false));\n"
        
        try:
            cur.execute(sql_1)
            conn.commit()
            
        except Exception as ex:
            print ("CREATE tbl_punts_finals_tmp TABLE ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "CREATE tbl_punts_finals_tmp TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
            return "ERROR"

#       *****************************************************************************************************************
#       FI DE LA CREACIO DE LA TAULA 'TBL_PUNTS_FINALS_TMP' QUE CONTINDRA ELS ID DELS NODES DE LA XARXA QUE SON A DINS DEL RADI 
#       *****************************************************************************************************************
#       *****************************************************************************************************************
#       INICI DE LA CREACIO DE LA TAULA 'GEO_PUNTS_FINALS_TMP' QUE CONTINDRA ELS NODES DE LA XARXA QUE SON A DINS DEL RADI 
#       *****************************************************************************************************************
        sql_1="DROP table if exists geo_punts_finals_tmp;\n"
        if (self.dlg.RB_campTaula.isChecked()):
            """Creació de la taula 'geo_punts_finals_tmp' on estan tots els nodes de la xarxa que son a dins del radi variable segons el camp escolit amb la geometria inclosa"""
            sql_1+="CREATE local temporary TABLE geo_punts_finals_tmp as (select \"" + XarxaCarrers + "_vertices_pgr\".*,\"tbl_punts_finals_tmp\".\"agg_cost\", \"tbl_punts_finals_tmp\".\"start_vid\", \"tbl_punts_finals_tmp\".\"init_radi\" from \"" + XarxaCarrers + "_vertices_pgr\",\"tbl_punts_finals_tmp\" where \"" + XarxaCarrers + "_vertices_pgr\".\"id\" =\"tbl_punts_finals_tmp\".\"node\" order by \"tbl_punts_finals_tmp\".\"start_vid\" desc,\"tbl_punts_finals_tmp\".\"agg_cost\");\n"
        else:
            """Creació de la taula 'geo_punts_finals_tmp' on estan tots els nodes de la xarxa que son a dins del radi fix amb la geometria inclosa"""
            sql_1+="CREATE local temporary TABLE geo_punts_finals_tmp as (select \"" + XarxaCarrers + "_vertices_pgr\".*,\"tbl_punts_finals_tmp\".\"agg_cost\", \"tbl_punts_finals_tmp\".\"start_vid\", "+self.dlg.TL_Dist_Cost_CCU.text()+" from \"" + XarxaCarrers + "_vertices_pgr\",\"tbl_punts_finals_tmp\" where \"" + XarxaCarrers + "_vertices_pgr\".\"id\" =\"tbl_punts_finals_tmp\".\"node\" order by \"tbl_punts_finals_tmp\".\"start_vid\" desc,\"tbl_punts_finals_tmp\".\"agg_cost\");\n"
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("CREATE geo_punts_finals_tmp TABLE ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "CREATE geo_punts_finals_tmp TABLE ERROR")
            conn.rollback()

            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"
#       *****************************************************************************************************************
#       FI DE LA CREACIO DE LA TAULA 'GEO_PUNTS_FINALS_TMP' QUE CONTINDRA ELS NODES DE LA XARXA QUE SON A DINS DEL RADI 
#       *****************************************************************************************************************
            
        
#       *****************************************************************************************************************
#       INICI DE LA CREACIO DE LA TAULA 'TRAMS_FINALS_TMP' QUE CONTINDRA ELS TRAMS QUE FORMEN PART DEL RADI D'ACCIO INDICAT 
#       *****************************************************************************************************************
        sql_1="DROP table IF EXISTS trams_finals_tmp;\n"
        if (self.dlg.comboMetodeTreball_CCU.currentText()=="Distancia"):
            """Si s'ha escollit calcula mitjançant distancia """
            #sql per distancia
            if (self.dlg.RB_campTaula.isChecked()):
                #"""Creaci� de la taula que contindr� els trams que formen part del radi d'acci� indicat,si el radi escollit es mitjan�ant un camp de la taula"""
                sql_1+="CREATE local temporary TABLE trams_finals_tmp as (select \"Xarxa_Graf\".\"id\",\"Xarxa_Graf\".\"geom\",\"geo_punts_finals_tmp\".\"id\" as node,\"geo_punts_finals_tmp\".\"agg_cost\" as coste,(\"geo_punts_finals_tmp\".\"init_radi\"-\"geo_punts_finals_tmp\".\"agg_cost\") as falta,\"geo_punts_finals_tmp\".\"start_vid\" as id_punt, (select case when (\"geo_punts_finals_tmp\".\"init_radi\"-\"geo_punts_finals_tmp\".\"agg_cost\")/ST_Length(\"Xarxa_Graf\".\"geom\")<=1 then (\"geo_punts_finals_tmp\".\"init_radi\"-\"geo_punts_finals_tmp\".\"agg_cost\")/ST_Length(\"Xarxa_Graf\".\"geom\") when (\"geo_punts_finals_tmp\".\"init_radi\"-\"geo_punts_finals_tmp\".\"agg_cost\")/ST_Length(\"Xarxa_Graf\".\"geom\")>1 then (1) end) as fraccio from \"Xarxa_Graf\",\"geo_punts_finals_tmp\" where ST_DWithin(\"geo_punts_finals_tmp\".\"the_geom\",\"Xarxa_Graf\".\"geom\",1)=TRUE);\n"
            else:
                """Creació de la taula que contindrà els trams que formen part del radi d'acció indicat, si el radi escollit es un radi fix"""
                sql_1+="CREATE local temporary TABLE trams_finals_tmp as (select \"Xarxa_Graf\".\"id\",\"Xarxa_Graf\".\"geom\",\"geo_punts_finals_tmp\".\"id\" as node,\"geo_punts_finals_tmp\".\"agg_cost\" as coste,("+self.dlg.TL_Dist_Cost_CCU.text()+"-\"geo_punts_finals_tmp\".\"agg_cost\") as falta,\"geo_punts_finals_tmp\".\"start_vid\" as id_punt, (select case when ("+self.dlg.TL_Dist_Cost_CCU.text()+"-\"geo_punts_finals_tmp\".\"agg_cost\")/ST_Length(\"Xarxa_Graf\".\"geom\")<=1 then ("+self.dlg.TL_Dist_Cost_CCU.text()+"-\"geo_punts_finals_tmp\".\"agg_cost\")/ST_Length(\"Xarxa_Graf\".\"geom\") when ("+self.dlg.TL_Dist_Cost_CCU.text()+"-\"geo_punts_finals_tmp\".\"agg_cost\")/ST_Length(\"Xarxa_Graf\".\"geom\")>1 then (1) end) as fraccio from \"Xarxa_Graf\",\"geo_punts_finals_tmp\" where ST_DWithin(\"geo_punts_finals_tmp\".\"the_geom\",\"Xarxa_Graf\".\"geom\",1)=TRUE);\n"
        else:
            """Si s'ha escollit calcula mitjançant Temps """
            if (self.dlg.chk_CostInvers_CCU.isChecked()):
                #sql per temps i cost invers
                if (self.dlg.RB_campTaula.isChecked()):
                    """Creació de la taula que contindrà els trams que formen part del radi d'acció indicat, si el radi escollit es mitjan�ant un camp de la taula"""
                    sql_1+="CREATE local temporary TABLE trams_finals_tmp as (select \"Xarxa_Graf\".\"id\",\"Xarxa_Graf\".\"cost\",\"Xarxa_Graf\".\"reverse_cost\",\"Xarxa_Graf\".\"geom\",\"geo_punts_finals_tmp\".\"id\" as node,\"geo_punts_finals_tmp\".\"agg_cost\" as coste,(\"geo_punts_finals_tmp\".\"init_radi\"-\"geo_punts_finals_tmp\".\"agg_cost\") as falta,\"geo_punts_finals_tmp\".\"start_vid\" as id_punt, (select case when ((\"geo_punts_finals_tmp\".\"init_radi\"-\"geo_punts_finals_tmp\".\"agg_cost\")/(CASE WHEN \"geo_punts_finals_tmp\".\"id\"=\"Xarxa_Graf\".\"target\" THEN \"Xarxa_Graf\".\"reverse_cost\" ELSE \"Xarxa_Graf\".\"cost\" END))<=1 then ((\"geo_punts_finals_tmp\".\"init_radi\"-\"geo_punts_finals_tmp\".\"agg_cost\")/(CASE WHEN \"geo_punts_finals_tmp\".\"id\"=\"Xarxa_Graf\".\"target\" THEN \"Xarxa_Graf\".\"reverse_cost\" ELSE \"Xarxa_Graf\".\"cost\" END)) when ((\"geo_punts_finals_tmp\".\"init_radi\"-\"geo_punts_finals_tmp\".\"agg_cost\")/(CASE WHEN \"geo_punts_finals_tmp\".\"id\"=\"Xarxa_Graf\".\"target\" THEN \"Xarxa_Graf\".\"reverse_cost\" ELSE \"Xarxa_Graf\".\"cost\" END))>1 then (1) end) as fraccio from \"Xarxa_Graf\",\"geo_punts_finals_tmp\" where ST_DWithin(\"geo_punts_finals_tmp\".\"the_geom\",\"Xarxa_Graf\".\"geom\",1)=TRUE);\n"
                else:
                    """Creació de la taula que contindrà els trams que formen part del radi d'acció indicat, si el radi escollit es un radi fix"""
                    sql_1+="CREATE local temporary TABLE trams_finals_tmp as (select \"Xarxa_Graf\".\"id\",\"Xarxa_Graf\".\"cost\",\"Xarxa_Graf\".\"reverse_cost\",\"Xarxa_Graf\".\"geom\",\"geo_punts_finals_tmp\".\"id\" as node,\"geo_punts_finals_tmp\".\"agg_cost\" as coste,("+self.dlg.TL_Dist_Cost_CCU.text()+"-\"geo_punts_finals_tmp\".\"agg_cost\") as falta,\"geo_punts_finals_tmp\".\"start_vid\" as id_punt, (select case when (("+self.dlg.TL_Dist_Cost_CCU.text()+"-\"geo_punts_finals_tmp\".\"agg_cost\")/(CASE WHEN \"geo_punts_finals_tmp\".\"id\"=\"Xarxa_Graf\".\"target\" THEN \"Xarxa_Graf\".\"reverse_cost\" ELSE \"Xarxa_Graf\".\"cost\" END))<=1 then (("+self.dlg.TL_Dist_Cost_CCU.text()+"-\"geo_punts_finals_tmp\".\"agg_cost\")/(CASE WHEN \"geo_punts_finals_tmp\".\"id\"=\"Xarxa_Graf\".\"target\" THEN \"Xarxa_Graf\".\"reverse_cost\" ELSE \"Xarxa_Graf\".\"cost\" END)) when (("+self.dlg.TL_Dist_Cost_CCU.text()+"-\"geo_punts_finals_tmp\".\"agg_cost\")/(CASE WHEN \"geo_punts_finals_tmp\".\"id\"=\"Xarxa_Graf\".\"target\" THEN \"Xarxa_Graf\".\"reverse_cost\" ELSE \"Xarxa_Graf\".\"cost\" END))>1 then (1) end) as fraccio from \"Xarxa_Graf\",\"geo_punts_finals_tmp\" where ST_DWithin(\"geo_punts_finals_tmp\".\"the_geom\",\"Xarxa_Graf\".\"geom\",1)=TRUE);\n"
            else:
                #sql per temps i sense cost invers
                if (self.dlg.RB_campTaula.isChecked()):
                    """Creació de la taula que contindrà els trams que formen part del radi d'acció indicat, si el radi escollit es mitjan�ant un camp de la taula"""
                    sql_1+="CREATE local temporary TABLE trams_finals_tmp as (select \"Xarxa_Graf\".\"id\",\"Xarxa_Graf\".\"cost\",\"Xarxa_Graf\".\"reverse_cost\",\"Xarxa_Graf\".\"geom\",\"geo_punts_finals_tmp\".\"id\" as node,\"geo_punts_finals_tmp\".\"agg_cost\" as coste,(\"geo_punts_finals_tmp\".\"init_radi\"-\"geo_punts_finals_tmp\".\"agg_cost\") as falta,\"geo_punts_finals_tmp\".\"start_vid\" as id_punt, (select case when ((\"geo_punts_finals_tmp\".\"init_radi\"-\"geo_punts_finals_tmp\".\"agg_cost\")/(\"Xarxa_Graf\".\"cost\"))<=1 then ((\"geo_punts_finals_tmp\".\"init_radi\"-\"geo_punts_finals_tmp\".\"agg_cost\")/(\"Xarxa_Graf\".\"cost\")) when ((\"geo_punts_finals_tmp\".\"init_radi\"-\"geo_punts_finals_tmp\".\"agg_cost\")/(\"Xarxa_Graf\".\"cost\"))>1 then (1) end) as fraccio from \"Xarxa_Graf\",\"geo_punts_finals_tmp\" where ST_DWithin(\"geo_punts_finals_tmp\".\"the_geom\",\"Xarxa_Graf\".\"geom\",1)=TRUE);\n"
                else:
                    """Creació de la taula que contindrà els trams que formen part del radi d'acció indicat, si el radi escollit es un radi fix"""
                    sql_1+="CREATE local temporary TABLE trams_finals_tmp as (select \"Xarxa_Graf\".\"id\",\"Xarxa_Graf\".\"cost\",\"Xarxa_Graf\".\"reverse_cost\",\"Xarxa_Graf\".\"geom\",\"geo_punts_finals_tmp\".\"id\" as node,\"geo_punts_finals_tmp\".\"agg_cost\" as coste,("+self.dlg.TL_Dist_Cost_CCU.text()+"-\"geo_punts_finals_tmp\".\"agg_cost\") as falta,\"geo_punts_finals_tmp\".\"start_vid\" as id_punt, (select case when (("+self.dlg.TL_Dist_Cost_CCU.text()+"-\"geo_punts_finals_tmp\".\"agg_cost\")/(\"Xarxa_Graf\".\"cost\"))<=1 then (("+self.dlg.TL_Dist_Cost_CCU.text()+"-\"geo_punts_finals_tmp\".\"agg_cost\")/(\"Xarxa_Graf\".\"cost\")) when (("+self.dlg.TL_Dist_Cost_CCU.text()+"-\"geo_punts_finals_tmp\".\"agg_cost\")/(\"Xarxa_Graf\".\"cost\"))>1 then (1) end) as fraccio from \"Xarxa_Graf\",\"geo_punts_finals_tmp\" where ST_DWithin(\"geo_punts_finals_tmp\".\"the_geom\",\"Xarxa_Graf\".\"geom\",1)=TRUE);\n"
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("CREATE trams_finals_tmp TABLE ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "CREATE trams_finals_tmp TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"        
#       *****************************************************************************************************************
#       FI DE LA CREACIO DE LA TAULA 'TRAMS_FINALS_TMP' QUE CONTINDRA ELS TRAMS QUE FORMEN PART DEL RADI D'ACCIO INDICAT 
#       *****************************************************************************************************************

#       *****************************************************************************************************************
#       INICI FUNCIO PER CREAR ELS TRAMS FINALS AMB LA FRACCIO DE TRAM QUE LI CORRESPON 
#       *****************************************************************************************************************
        sql_1="DROP FUNCTION IF EXISTS Cobertura();\n"
        sql_1+="CREATE OR REPLACE FUNCTION Cobertura() RETURNS SETOF trams_finals_tmp AS\n"
        sql_1+="$BODY$\n"
        sql_1+="DECLARE\n"
        sql_1+="r trams_finals_tmp%rowtype;\n"
        sql_1+="m trams_finals_tmp%rowtype;\n"
        sql_1+="BEGIN\n"
        sql_1+="DROP TABLE IF EXISTS fraccio_trams_raw;\n"
        sql_1+="CREATE local temporary TABLE fraccio_trams_raw (geom geometry, punt_id bigint,id_tram bigint,fraccio FLOAT,node bigint,fraccio_inicial FLOAT,cost_invers FLOAT,cost_directe FLOAT,target bigint,radi_inic FLOAT);\n"
        sql_1+="FOR r IN SELECT \"trams_finals_tmp\".* FROM \"trams_finals_tmp\" WHERE \"trams_finals_tmp\".\"id\" not in (select \"edge_id\" from \"punts_interes_tmp\")\n"
        sql_1+="LOOP\n"
        sql_1+="insert into fraccio_trams_raw VALUES(ST_LineSubstring((r.\"geom\"),"
        sql_1+="case when (select ST_LineLocatePoint((r.\"geom\"),(select \"geo_punts_finals_tmp\".\"the_geom\" from \"geo_punts_finals_tmp\" where \"geo_punts_finals_tmp\".\"id\"=r.\"node\" and \"geo_punts_finals_tmp\".\"start_vid\"=r.\"id_punt\")))<0.001 then 0 else 1-r.\"fraccio\"\n"
        sql_1+="END,\n"
        sql_1+="case when (select ST_LineLocatePoint((r.\"geom\"),(select \"geo_punts_finals_tmp\".\"the_geom\" from \"geo_punts_finals_tmp\" where \"geo_punts_finals_tmp\".\"id\"=r.\"node\" and \"geo_punts_finals_tmp\".\"start_vid\"=r.\"id_punt\")))<0.001 then r.\"fraccio\" else 1\n"
        sql_1+="END),r.\"id_punt\"*(-1),r.\"id\",0,r.\"node\",0,0,0,0);\n"
        sql_1+="RETURN NEXT r;\n"
        sql_1+="END LOOP;\n"

        sql_1+="FOR m IN SELECT \"trams_finals_tmp\".* FROM \"trams_finals_tmp\" WHERE \"trams_finals_tmp\".\"id\" in (select \"edge_id\" from \"punts_interes_tmp\")\n"
        sql_1+="LOOP\n"
        sql_1+="insert into fraccio_trams_raw VALUES(m.\"geom\",m.\"id_punt\"*(-1),m.\"id\",0,m.\"node\",0,0,0);\n"

        sql_1+="RETURN NEXT m;\n"
        sql_1+="END LOOP;\n"

        sql_1+="RETURN;\n"
        sql_1+="END\n"
        sql_1+="$BODY$\n"
        sql_1+="LANGUAGE 'plpgsql' ;\n"
        
        sql_1+="SELECT \"geom\" FROM Cobertura();\n"

        progress.setValue(45)
        self.dlg.Progres.setValue(45)
        QApplication.processEvents()

        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("Select Cobertura ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "Select Cobertura ERROR")
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"
            
        sql_1="DROP FUNCTION IF EXISTS Cobertura();\n"
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("Error DROP Cobertura")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error DROP Cobertura")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()
            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
            return "ERROR"
#       *****************************************************************************************************************
#       FI FUNCIO PER CREAR ELS TRAMS FINALS AMB LA FRACCIO DE TRAM QUE LI CORRESPON 
#       *****************************************************************************************************************

#       *****************************************************************************************************************
#       INICI ACTUALITZACIO DE LA FRACCIO DELS TRAMS INICIALS 
#       *****************************************************************************************************************
        """Actualitzaci� de la fracci� dels trams inicials  """
        sql_1="update \"fraccio_trams_raw\" set \"fraccio_inicial\"=\"punts_interes_tmp\".\"fraction\" from \"punts_interes_tmp\" where \"id_tram\"=\"edge_id\""
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("UPDATE fraccio_trams_raw TABLE ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "UPDATE fraccio_trams_raw TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"        
#       *****************************************************************************************************************
#       FI ACTUALITZACIO DE LA FRACCIO DELS TRAMS INICIALS 
#       *****************************************************************************************************************

#       *****************************************************************************************************************
#       INICI ACTUALITZACIO DELS VALORS DE COST DIRECTE, TARGET, COST INVERS DELS TRAMS INICIALS 
#       *****************************************************************************************************************
        """Actualitzaci� dels valors de cost directe, target, cost invers dels trams inicials"""
        sql_1="update \"fraccio_trams_raw\" set \"cost_directe\"=\"Xarxa_Graf\".\"cost\",\"target\"=\"Xarxa_Graf\".\"target\",\"cost_invers\"=\"Xarxa_Graf\".\"reverse_cost\" from \"Xarxa_Graf\" where \"id_tram\"=\"id\""

        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("UPDATE 2 fraccio_trams_raw TABLE ERROR 2")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "UPDATE 2 fraccio_trams_raw TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"        

#       *****************************************************************************************************************
#       FI ACTUALITZACIO DELS VALORS DE COST DIRECTE, TARGET, COST INVERS DELS TRAMS INICIALS 
#       *****************************************************************************************************************

#       *****************************************************************************************************************
#       INICI ACTUALITZACIO DEL VALOR DEL CAMP RADI INICIAL EN EL CASE QUE SIGUI RADI VARIABLE 
#       *****************************************************************************************************************
        if (self.dlg.RB_campTaula.isChecked()):
            """En el cas de radi variable, s'actualiza el camp radi inicial dels trams inicials """
            sql_1="update \"fraccio_trams_raw\" set \"radi_inic\"=\"geo_punts_finals_tmp\".\"init_radi\" from \"geo_punts_finals_tmp\" where \"punt_id\"*-1=\"start_vid\""
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("UPDATE 3 fraccio_trams_raw TABLE ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "UPDATE 3 fraccio_trams_raw TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"        
#       *****************************************************************************************************************
#       FI ACTUALITZACIO DEL VALOR DEL CAMP RADI INICIAL EN EL CASE QUE SIGUI RADI VARIABLE 
#       *****************************************************************************************************************

        
#       *****************************************************************************************************************
#       INICI CALCUL DE LA FRACCIO DE CADA TRAM FINAL 
#       *****************************************************************************************************************
        if (self.dlg.comboMetodeTreball_CCU.currentText()!="Distancia"):
            """Calcul del la fracci� final de cada tram en el cas d'haber escollit temps"""
            cost_tram="(CASE WHEN \"geo_punts_finals_tmp\".\"id\"=\"fraccio_trams_raw\".\"target\" THEN \"fraccio_trams_raw\".\"cost_invers\" ELSE \"fraccio_trams_raw\".\"cost_directe\" END)"
            where_tram=" FROM \"geo_punts_finals_tmp\" WHERE ST_DWithin(\"geo_punts_finals_tmp\".\"the_geom\",\"fraccio_trams_raw\".\"geom\",1)=TRUE"
            sql_1="UPDATE \"fraccio_trams_raw\" SET \"fraccio\"=" 
            if (self.dlg.RB_campTaula.isChecked()):
                """ Si el radi es variable"""
                sql_1+="((case when (\"fraccio_trams_raw\".\"fraccio_inicial\"*"+cost_tram+")>\"fraccio_trams_raw\".\"radi_inic\" then (\"fraccio_trams_raw\".\"radi_inic\"/"+cost_tram+") else \"fraccio_trams_raw\".\"fraccio_inicial\" end)"
                sql_1+="+"
                sql_1+="(case when ((1-\"fraccio_trams_raw\".\"fraccio_inicial\")*"+cost_tram+")>\"fraccio_trams_raw\".\"radi_inic\" then (\"fraccio_trams_raw\".\"radi_inic\"/"+cost_tram+") else (1-\"fraccio_trams_raw\".\"fraccio_inicial\") end))"
                sql_1+=where_tram+";\n"
            else:
                """ Si el radi es fix"""
                sql_1+="((case when (\"fraccio_trams_raw\".\"fraccio_inicial\"*"+cost_tram+")>"+self.dlg.TL_Dist_Cost_CCU.text()+" then ("+self.dlg.TL_Dist_Cost_CCU.text()+"/"+cost_tram+") else \"fraccio_trams_raw\".\"fraccio_inicial\" end)"
                sql_1+="+"
                sql_1+="(case when ((1-\"fraccio_trams_raw\".\"fraccio_inicial\")*"+cost_tram+")>"+self.dlg.TL_Dist_Cost_CCU.text()+" then ("+self.dlg.TL_Dist_Cost_CCU.text()+"/"+cost_tram+") else (1-\"fraccio_trams_raw\".\"fraccio_inicial\") end))"
                sql_1+=where_tram+";\n"
        else:
            """Calcul del la fracci� final de cada tram en el cas d'haber escollit distancia"""
            cost_tram="ST_Length(\"fraccio_trams_raw\".\"geom\")"
            where_tram=""
            sql_1="UPDATE \"fraccio_trams_raw\" SET \"fraccio\"=" 
            if (self.dlg.RB_campTaula.isChecked()):
                """ Si el radi es variable"""
                sql_1+="((case when (\"fraccio_trams_raw\".\"fraccio_inicial\"*"+cost_tram+")>\"fraccio_trams_raw\".\"radi_inic\" then (\"fraccio_trams_raw\".\"radi_inic\"/"+cost_tram+") else \"fraccio_trams_raw\".\"fraccio_inicial\" end)"
                sql_1+="+"
                sql_1+="(case when ((1-\"fraccio_trams_raw\".\"fraccio_inicial\")*"+cost_tram+")>\"fraccio_trams_raw\".\"radi_inic\" then (\"fraccio_trams_raw\".\"radi_inic\"/"+cost_tram+") else (1-\"fraccio_trams_raw\".\"fraccio_inicial\") end))"
                sql_1+=where_tram+";\n"
            else:
                """ Si el radi es fix"""
                sql_1+="((case when (\"fraccio_trams_raw\".\"fraccio_inicial\"*"+cost_tram+")>"+self.dlg.TL_Dist_Cost_CCU.text()+" then ("+self.dlg.TL_Dist_Cost_CCU.text()+"/"+cost_tram+") else \"fraccio_trams_raw\".\"fraccio_inicial\" end)"
                sql_1+="+"
                sql_1+="(case when ((1-\"fraccio_trams_raw\".\"fraccio_inicial\")*"+cost_tram+")>"+self.dlg.TL_Dist_Cost_CCU.text()+" then ("+self.dlg.TL_Dist_Cost_CCU.text()+"/"+cost_tram+") else (1-\"fraccio_trams_raw\".\"fraccio_inicial\") end))"
                sql_1+=where_tram+";\n"
        
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("UPDATE 4 fraccio_trams_raw TABLE ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "UPDATE 4 fraccio_trams_raw TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"        

#       *****************************************************************************************************************
#       FI CALCUL DE LA FRACCIO DE CADA TRAM FINAL 
#       *****************************************************************************************************************

#       *****************************************************************************************************************
#       INICI MODIFICACIO DE LA GEOMETRIA DELS TRAMS FINALS SEGONS LA FRACCIO CALCULADA 
#       *****************************************************************************************************************
        """Es modifiquen els trams finals del trajecte segons el que falti per arribar al cost desitjat"""
        sql_1="update \"fraccio_trams_raw\" set \"geom\"=final.\"geom\"" 
        sql_1+="from"
        sql_1+="(select distinct(ST_LineSubstring("
        sql_1+="(m.\"geom\")"
        sql_1+=","
        sql_1+="(case when (select ST_LineLocatePoint((m.\"geom\"),(select \"the_geom\" from \"geo_punts_finals_tmp\" where \"geo_punts_finals_tmp\".\"id\"=m.\"node\" and \"geo_punts_finals_tmp\".\"start_vid\"=m.\"punt_id\"*-1)))<0.01 then 0 else 1-m.\"fraccio\" END)"
        sql_1+=","
        sql_1+="(case when (select ST_LineLocatePoint((m.\"geom\"),(select \"the_geom\" from \"geo_punts_finals_tmp\" where \"geo_punts_finals_tmp\".\"id\"=m.\"node\" and \"geo_punts_finals_tmp\".\"start_vid\"=m.\"punt_id\"*-1)))<0.01 then m.\"fraccio\" else 1 END)"
        sql_1+="))  geom"
        sql_1+=","
        sql_1+="m.\"id_tram\""
        sql_1+="from \"fraccio_trams_raw\" m "
        sql_1+="where m.\"id_tram\" in (select \"edge_id\" from \"punts_interes_tmp\")) final "
        sql_1+="where final.\"id_tram\" =\"fraccio_trams_raw\".\"id_tram\";\n"
        progress.setValue(55)
        self.dlg.Progres.setValue(55)
        QApplication.processEvents()
        
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("UPDATE 5 fraccio_trams_raw TABLE ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "UPDATE 5 fraccio_trams_raw TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"        
#       *****************************************************************************************************************
#       FI MODIFICACIO DE LA GEOMETRIA DELS TRAMS FINALS SEGONS LA FRACCIO CALCULADA 
#       *****************************************************************************************************************
        
#       *****************************************************************************************************************
#       INICI INSERTAR ELS TRAMS INICIALS DELS QUE PARTIRA EL GRAF 
#       *****************************************************************************************************************
        """S'afegeixen els trams inicials de cada graf per modificarlos posteriorment"""
        sql_1="insert into \"fraccio_trams_raw\" (select SX.\"geom\",PI.\"pid\" as punt_id,SX.\"id\"as id_tram,999 as fraccio,SX.\"source\" as node,PI.\"fraction\" as fraccio_inicial,SX.\"cost\",SX.\"reverse_cost\" from \"Xarxa_Graf\" SX inner join (Select \"edge_id\",\"pid\",\"fraction\" from \"punts_interes_tmp\") PI on SX.\"id\"=PI.\"edge_id\");\n"
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("INSERT fraccio_trams_raw TABLE ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "INSERT fraccio_trams_raw TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"        
#       *****************************************************************************************************************
#       FI INSERTAR ELS TRAMS INICIALS DELS QUE PARTIRA EL GRAF 
#       *****************************************************************************************************************

#       *****************************************************************************************************************
#       INICI MODIFICACIO DELS TRAMS INICIALS EN EL CAS QUE LA DISTANCIA A RECORRER SIGUI MES PETITA QUE EL PROPI TRAM 
#       *****************************************************************************************************************
        if (self.dlg.comboMetodeTreball_CCU.currentText()=="Distancia"):
            """ Calcul amb distancia i radi variable"""
            if (self.dlg.RB_campTaula.isChecked()):
                """En el cas de radi variable, s'actualiza el camp radi inicial dels trams inicials """
                sql_1="update \"fraccio_trams_raw\" set \"radi_inic\"=\"tbl_punts_finals_tmp\".\"init_radi\" from \"tbl_punts_finals_tmp\" where \"punt_id\"*-1=\"start_vid\" and \"fraccio\"=999"
                try:
                    cur.execute(sql_1)
                    conn.commit()
                except Exception as ex:
                    print ("UPDATE 6 fraccio_trams_raw TABLE ERROR")
                    
                    template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                    message = template.format(type(ex).__name__, ex.args)
                    print (message)
                    
                    QMessageBox.information(None, "Error", "UPDATE 6 fraccio_trams_raw TABLE ERROR")
                    conn.rollback()
                    self.eliminaTaulesCalcul(Fitxer)
                    self.eliminaTaulesTemporals()
        
                    self.bar.clearWidgets()
                    self.dlg.Progres.setValue(0)
                    self.dlg.Progres.setVisible(False)
                    self.dlg.lblEstatConn.setText('Connectat')
                    self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                                    
                    return "ERROR"        
            
                cost_tram="ST_Length(SXI.\"geom\")"
                sql_1="UPDATE \"fraccio_trams_raw\" set \"geom\"=final.\"geom\" from (select ST_LineSubstring((SXI.\"geom\"),"
                sql_1+="(case when (FT.\"fraccio_inicial\"-(FT.\"radi_inic\"/"+cost_tram+"))>0 then (FT.\"fraccio_inicial\"-(FT.\"radi_inic\"/"+cost_tram+")) else 0 end)"
                sql_1+=","
                sql_1+="(case when (FT.\"fraccio_inicial\"+(FT.\"radi_inic\"/"+cost_tram+"))<1 then (FT.\"fraccio_inicial\"+(FT.\"radi_inic\"/"+cost_tram+")) else 1 end)"
                sql_1+=") as geom, FT.\"punt_id\",FT.\"id_tram\",FT.\"fraccio\" "
                sql_1+="from \"fraccio_trams_raw\"FT inner join (select SX.\"geom\" as geom,SX.\"id\" as tram_xarxa from \"Xarxa_Graf\" SX, \"punts_interes_tmp\" PI where SX.\"id\"=PI.\"edge_id\") SXI on FT.\"id_tram\"=SXI.tram_xarxa where FT.\"fraccio\"=999) final"
                sql_1+=" where \"fraccio_trams_raw\".\"punt_id\"=final.\"punt_id\" and \"fraccio_trams_raw\".\"fraccio\"=999;\n"
            else:
                """ Calcul amb distancia i radi fix"""
                cost_tram="ST_Length(SXI.\"geom\")"
                sql_1="UPDATE \"fraccio_trams_raw\" set \"geom\"=final.\"geom\" from (select ST_LineSubstring((SXI.\"geom\"),"
                sql_1+="(case when (FT.\"fraccio_inicial\"-("+self.dlg.TL_Dist_Cost_CCU.text()+"/"+cost_tram+"))>0 then (FT.\"fraccio_inicial\"-("+self.dlg.TL_Dist_Cost_CCU.text()+"/"+cost_tram+")) else 0 end)"
                sql_1+=","
                sql_1+="(case when (FT.\"fraccio_inicial\"+("+self.dlg.TL_Dist_Cost_CCU.text()+"/"+cost_tram+"))<1 then (FT.\"fraccio_inicial\"+("+self.dlg.TL_Dist_Cost_CCU.text()+"/"+cost_tram+")) else 1 end)"
                sql_1+=") as geom, FT.\"punt_id\",FT.\"id_tram\",FT.\"fraccio\" "
                sql_1+="from \"fraccio_trams_raw\"FT inner join (select SX.\"geom\" as geom,SX.\"id\" as tram_xarxa from \"Xarxa_Graf\" SX, \"punts_interes_tmp\" PI where SX.\"id\"=PI.\"edge_id\") SXI on FT.\"id_tram\"=SXI.tram_xarxa where FT.\"fraccio\"=999) final"
                sql_1+=" where \"fraccio_trams_raw\".\"punt_id\"=final.\"punt_id\" and \"fraccio_trams_raw\".\"fraccio\"=999;\n"
        else:
            """ Calcul amb temps i radi variable"""
            if (self.dlg.RB_campTaula.isChecked()):
                """En el cas de radi variable, s'actualiza el camp radi inicial dels trams inicials """
                sql_1="update \"fraccio_trams_raw\" set \"radi_inic\"=\"tbl_punts_finals_tmp\".\"init_radi\" from \"tbl_punts_finals_tmp\" where \"punt_id\"*-1=\"start_vid\" and \"fraccio\"=999"
                try:
                    cur.execute(sql_1)
                    conn.commit()
                except Exception as ex:
                    print ("UPDATE 7 fraccio_trams_raw TABLE ERROR")
                    
                    template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                    message = template.format(type(ex).__name__, ex.args)
                    print (message)
                    
                    QMessageBox.information(None, "Error", "UPDATE 7 fraccio_trams_raw TABLE ERROR")
                    conn.rollback()
                    self.eliminaTaulesCalcul(Fitxer)
                    self.eliminaTaulesTemporals()
        
                    self.bar.clearWidgets()
                    self.dlg.Progres.setValue(0)
                    self.dlg.Progres.setVisible(False)
                    self.dlg.lblEstatConn.setText('Connectat')
                    self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                                    
                    return "ERROR"        
                sql_1="UPDATE \"fraccio_trams_raw\" set \"geom\"=final.\"geom\" from "
                sql_1+="(select ST_Union(TOT.geom) geom,TOT.\"punt_id\" from (select ST_LineSubstring((SXI.\"geom\"),"
                sql_1+="(case when (FT.\"fraccio_inicial\"-(FT.\"radi_inic\"/(FT.\"cost_invers\")))>0 then (FT.\"fraccio_inicial\"-(FT.\"radi_inic\"/(FT.\"cost_invers\"))) else 0 end)"
                sql_1+=","
                sql_1+="FT.\"fraccio_inicial\""
                sql_1+=") as geom, FT.\"punt_id\" "
                sql_1+="from \"fraccio_trams_raw\"FT inner join (select SX.\"geom\" as geom,SX.\"id\" as tram_xarxa from \"Xarxa_Graf\" SX, \"punts_interes_tmp\" PI where SX.\"id\"=PI.\"edge_id\") SXI on FT.\"id_tram\"=SXI.tram_xarxa where FT.\"fraccio\"=999 "
                sql_1+="UNION "
                sql_1+="select ST_LineSubstring((SXI.\"geom\"),"
                sql_1+="FT.\"fraccio_inicial\""
                sql_1+=","
                sql_1+="(case when (FT.\"fraccio_inicial\"+(FT.\"radi_inic\"/(FT.\"cost_directe\")))<1 then (FT.\"fraccio_inicial\"+(FT.\"radi_inic\"/(FT.\"cost_directe\"))) else 1 end)"
                sql_1+=") as geom, FT.\"punt_id\" "
                sql_1+="from \"fraccio_trams_raw\"FT inner join (select SX.\"geom\" as geom,SX.\"id\" as tram_xarxa from \"Xarxa_Graf\" SX, \"punts_interes_tmp\" PI where SX.\"id\"=PI.\"edge_id\") SXI on FT.\"id_tram\"=SXI.tram_xarxa where FT.\"fraccio\"=999) TOT GROUP BY TOT.\"punt_id\") final"
                sql_1+=" where \"fraccio_trams_raw\".\"punt_id\"=final.\"punt_id\" and \"fraccio_trams_raw\".\"fraccio\"=999;\n"
            else:
                """ Calcul amb temps i radi fix"""
                sql_1="UPDATE \"fraccio_trams_raw\" set \"geom\"=final.\"geom\" from "
                sql_1+="(select ST_Union(TOT.geom) geom,TOT.\"punt_id\" from (select ST_LineSubstring((SXI.\"geom\"),"
                sql_1+="(case when (FT.\"fraccio_inicial\"-("+self.dlg.TL_Dist_Cost_CCU.text()+"/(FT.\"cost_invers\")))>0 then (FT.\"fraccio_inicial\"-("+self.dlg.TL_Dist_Cost_CCU.text()+"/(FT.\"cost_invers\"))) else 0 end)"
                sql_1+=","
                sql_1+="FT.\"fraccio_inicial\""
                sql_1+=") as geom, FT.\"punt_id\" "
                sql_1+="from \"fraccio_trams_raw\"FT inner join (select SX.\"geom\" as geom,SX.\"id\" as tram_xarxa from \"Xarxa_Graf\" SX, \"punts_interes_tmp\" PI where SX.\"id\"=PI.\"edge_id\") SXI on FT.\"id_tram\"=SXI.tram_xarxa where FT.\"fraccio\"=999 "
                sql_1+="UNION "
                sql_1+="select ST_LineSubstring((SXI.\"geom\"),"
                sql_1+="FT.\"fraccio_inicial\""
                sql_1+=","
                sql_1+="(case when (FT.\"fraccio_inicial\"+("+self.dlg.TL_Dist_Cost_CCU.text()+"/(FT.\"cost_directe\")))<1 then (FT.\"fraccio_inicial\"+("+self.dlg.TL_Dist_Cost_CCU.text()+"/(FT.\"cost_directe\"))) else 1 end)"
                sql_1+=") as geom, FT.\"punt_id\" "
                sql_1+="from \"fraccio_trams_raw\"FT inner join (select SX.\"geom\" as geom,SX.\"id\" as tram_xarxa from \"Xarxa_Graf\" SX, \"punts_interes_tmp\" PI where SX.\"id\"=PI.\"edge_id\") SXI on FT.\"id_tram\"=SXI.tram_xarxa where FT.\"fraccio\"=999) TOT GROUP BY TOT.\"punt_id\") final"
                sql_1+=" where \"fraccio_trams_raw\".\"punt_id\"=final.\"punt_id\" and \"fraccio_trams_raw\".\"fraccio\"=999;\n"
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("UPDATE 8 fraccio_trams_raw TABLE ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "UPDATE 8 fraccio_trams_raw TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"        
#       *****************************************************************************************************************
#       FI MODIFICACIO DELS TRAMS INICIALS EN EL CAS QUE LA DISTANCIA A RECORRER SIGUI MES PETITA QUE EL PROPI TRAM 
#       *****************************************************************************************************************


#       *****************************************************************************************************************
#       INICI CREACIO TAULA FRACCIO_TRAMS_TMP I ELIMINACIO DE TRAMS DUPLICATS 
#       *****************************************************************************************************************
        sql_1="DROP TABLE IF EXISTS fraccio_trams_tmp;\n"

        """Eliminaci� de trams duplicats"""
        sql_1+="CREATE local temporary TABLE fraccio_trams_tmp AS (select distinct(geom),punt_id,radi_inic from fraccio_trams_raw);\n"
        
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("CREATE fraccio_trams_tmp TABLE ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "CREATE fraccio_trams_tmp TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"        
#       *****************************************************************************************************************
#       FI CREACIO TAULA FRACCIO_TRAMS_TMP I ELIMINACIO DE TRAMS DUPLICATS 
#       *****************************************************************************************************************

#       *****************************************************************************************************************
#       INICI CREACIO TAULA GRAF_UTILITZAT_(DATA) QUE CONTINDRA ELS TRAMS UNITS DEL GRAF 
#       *****************************************************************************************************************
        """ Es fa la uni� de tots els trams des del servidor POSTGRES dins de la taula Graf_utilitzat_(data)"""
        sql_1="drop table if exists Graf_utilitzat_"+Fitxer+";\n"
        sql_1+="CREATE TABLE Graf_utilitzat_"+Fitxer+" AS (Select ST_Union(TOT.geom) geom, TOT.\"punt_id\" as id from (select geom,punt_id,radi_inic from fraccio_trams_tmp) TOT group by TOT.\"punt_id\");\n"
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("CREATE Graf_utilitzat_ TABLE ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "CREATE Graf_utilitzat_ TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"  
#       *****************************************************************************************************************
#       FI CREACIO TAULA GRAF_UTILITZAT_(DATA) QUE CONTINDRA ELS TRAMS UNITS DEL GRAF 
#       *****************************************************************************************************************

#       *****************************************************************************************************************
#       INICI CREACIO TAULA BUFFER_FINAL_(DATA) QUE CONTINDRA EL BUFFER DE LA UNIO DELS TRAMS 
#       *****************************************************************************************************************
        sql_1+="drop table if exists Buffer_Final_"+Fitxer+";\n"
        sql_1+="CREATE TABLE Buffer_Final_"+Fitxer+" AS (Select ST_Union(TOT.geom) geom, TOT.\"punt_id\" from (Select ST_Buffer(geom,"+self.dlg.TL_radiZI.text()+") geom,punt_id from fraccio_trams_tmp)TOT group by TOT.\"punt_id\");\n"
            
        try:
            cur.execute(sql_1)
            conn.commit()
        except Exception as ex:
            print ("CREATE Buffer_Final TABLE ERROR")
            
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            
            QMessageBox.information(None, "Error", "CREATE Buffer_Final TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            
            return "ERROR"
#       *****************************************************************************************************************
#       FI CREACIO TAULA BUFFER_FINAL_(DATA) QUE CONTINDRA EL BUFFER DE LA UNIO DELS TRAMS 
#       *****************************************************************************************************************
        '''
        if not(self.dlg.checkBoxDibuix.isChecked()):
            sql_1="drop table if exists Graf_utilitzat_"+Fitxer+";\n"
            cur.execute(sql_1)
            conn.commit()
        '''
        sql_total="SELECT * FROM Buffer_Final_"+Fitxer
        return sql_total


    def on_click_OK(self):
        """Aquesta funcio genera tots els calculs amb tots el parametres que li hem introduit
        a la finestra a traves dels elements de la interficie."""
        #Mirar si la entitat seleccionada retorna True o False, volent dir que es correcte o per el contrari hi falten alguns camps a la taula necessaris per fer els càlculs
        global micolor
        global micolorArea
        global Fitxer
        global cur
        global conn
        global nomBD1
        global contra1
        global host1
        global port1
        global usuari1
        global schema
        global progress
        global geometria
        global TEMPORARY_PATH
        global tipus_entitat_punt

        self.dlg.setEnabled(False)
        Fitxer="ccu_temp"+datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")

        errors = self.controlErrors()
        if len(errors) > 0:
            llista = "Llista d'errors:\n\n"
            for i in range (0,len(errors)):
                llista += ("- "+errors[i] + '\n') 
                
            QMessageBox.information(None, "Error", llista)
            self.dlg.setEnabled(True)
            return
        
        arxiuLlegit = False
        self.dlg.Progres.setValue(0)
        self.dlg.Progres.setVisible(False)
        QApplication.processEvents()
        

        if self.dlg.tabWidget_Destino.currentIndex() == 0:
            select = 'select count (*) from \"'+self.dlg.comboSelPunts.currentText()+'\"'
            try:                
                cur.execute(select)
                auxlist = cur.fetchall()
                if auxlist[0][0] == 0:
                    ErrorMessage = 'La entitat escollida es buida'
                    QMessageBox.information(None, "Error", ErrorMessage+'\n')
                    self.bar.clearWidgets()
                    self.dlg.Progres.setValue(0)
                    self.dlg.Progres.setVisible(False)
                    self.dlg.lblEstatConn.setText('Connectat')
                    self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                    self.dlg.setEnabled(True)
                    return
            except Exception as ex:
                print("ERROR select count")
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", "ERROR select count")
                self.eliminaTaulesCalcul(Fitxer)
                self.eliminaTaulesTemporals()
    
                self.bar.clearWidgets()
                self.dlg.Progres.setValue(0)
                self.dlg.Progres.setVisible(False)
                self.dlg.lblEstatConn.setText('Connectat')
                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                self.dlg.setEnabled(True)
                return
        
        try:
            self.detect_database_version()
        except Exception as ex:
            print("ERROR creant la taula temporal de la version antiga")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "ERROR creant la taula temporal de la version antiga")
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
            self.dlg.setEnabled(True)
            return

#       *****************************************************************************************f************************
#       INICI CREACIO DE LES TAULES RESUM DESDE EL CSV SUMINISTRAT 
#       *****************************************************************************************************************
        if (self.dlg.chk_poblacio.isChecked()):
            path = QFileDialog.getExistingDirectory(self.dlg,
                    "Busca la carpeta que conté els arxius provinents del mòdul TAULA RESUM",  Path_Inicial+"\\",
                    QFileDialog.ShowDirsOnly)
            trobat = True
            a=time.time()
            while trobat:
                if (path != ''):
                    if versio_db == "1.0":
                        ver = "v1"
                    else:
                        ver = "v2"
                    if (os.path.exists(path + f"/tr_illes_{ver}.csv")):
                        trobat = False 
                        
                        arxiu = open(path + f"/tr_illes_{ver}.csv", 'r')
                        dummy=arxiu.readline()
                        lines = arxiu.readlines()
                        try:
                            """Creació de la taula temporal Illes_resum_(data) de les dades del CSV de la taula resum d'illes"""
                            cur.execute("CREATE TABLE \"Illes_Resum_"+Fitxer+"\" (\"ILLES_Codificades\" varchar(20), \"Habitants\" numeric);")
                            conn.commit()
                            insert=""
                            for linia in lines:
                                vec = linia.split(';', 20 )
                                insert += "INSERT INTO \"Illes_Resum_"+Fitxer+"\" (\"ILLES_Codificades\", \"Habitants\") VALUES ('"+ vec[0] + "', "+ vec[1]+ ");\n"
                            cur.execute(insert)
                            conn.commit()
                        except Exception as ex:
                            print ("I am unable to connect to the database")
                            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                            message = template.format(type(ex).__name__, ex.args)
                            print (message)
                            QMessageBox.information(None, "Error", "I am unable to connect to the database")
                            conn.rollback()
                            self.eliminaTaulesCalcul(Fitxer)
                            self.eliminaTaulesTemporals()
                
                            self.bar.clearWidgets()
                            self.dlg.Progres.setValue(0)
                            self.dlg.Progres.setVisible(False)
                            self.dlg.lblEstatConn.setText('Connectat')
                            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            self.dlg.setEnabled(True)
                            return
                            
                        arxiu.close()
                        arxiuLlegit = True
                    else:
                        print ("No hi ha l'arxiu")
                        path = QFileDialog.getExistingDirectory(self.dlg,"Busca la carpeta que conté els arxius provinents del mòdul TAULA RESUM",  Path_Inicial+"/",QFileDialog.ShowDirsOnly)
                else:
                    print ("Cancelat")
                    self.bar.setEnabled(True)
                    self.bar.clearWidgets()
                    self.dlg.Progres.setVisible(False)
                    self.dlg.Progres.setValue(0)
                   
                    self.dlg.setEnabled(True)
                    self.bar.clearWidgets()
                    self.eliminaTaulesCalcul(Fitxer)
                    self.eliminaTaulesTemporals()
                    return
                   
                
                if (self.dlg.bt_Parcel.isChecked()):
                    if (path != ''):
                        if versio_db == "1.0":
                            ver = "v1"
                        else:
                            ver = "v2"
                        if (os.path.exists(path + f"/tr_parceles_{ver}.csv")):
                            trobat = False 
                            
                            arxiu = open(path + f"/tr_parceles_{ver}.csv", 'r')
                            dummy=arxiu.readline()
                            lines = arxiu.readlines()
                            try:
                                """Creaci� de la taula temporal Resum_Temp_(data) de les dades del CSV de la taula resum de parceles"""
                                cur.execute("CREATE TABLE \"Resum_Temp_"+Fitxer+"\" (\"Parcela\" varchar(20), \"Habitants\" numeric);")
                                conn.commit()
                                insert=""
                                for linia in lines:
                                    vec = linia.split(';', 20 )
                                    insert += "INSERT INTO \"Resum_Temp_"+Fitxer+"\" (\"Parcela\", \"Habitants\") VALUES ('"+ vec[0] + "', "+ vec[1]+ ");\n"
                                cur.execute(insert)
                                conn.commit()
                                #print "ok"                
                            except Exception as ex:
                                print ("I am unable to connect to the database")
                                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                                message = template.format(type(ex).__name__, ex.args)
                                print (message) 
                                QMessageBox.information(None, "Error", "I am unable to connect to the database")
                                conn.rollback()
                                self.eliminaTaulesCalcul(Fitxer)
                                self.eliminaTaulesTemporals()
                    
                                self.bar.clearWidgets()
                                self.dlg.Progres.setValue(0)
                                self.dlg.Progres.setVisible(False)
                                self.dlg.lblEstatConn.setText('Connectat')
                                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                                self.dlg.setEnabled(True)
                                return
                        
                        
                            arxiu.close()
                            arxiuLlegit = True
                        else:
                            print ("No hi ha l'arxiu")
                            path = QFileDialog.getExistingDirectory(self.dlg,"Busca la carpeta que conté els arxius provinents del mòdul TAULA RESUM",  Path_Inicial+"/",QFileDialog.ShowDirsOnly)
                    else:
                        print ("Cancelat")
                        self.bar.setEnabled(True)
                        self.bar.clearWidgets()
                        self.dlg.Progres.setVisible(False)
                        self.dlg.Progres.setValue(0)
                       
                        self.dlg.setEnabled(True)
                        self.bar.clearWidgets()
                        self.eliminaTaulesCalcul(Fitxer)
                        self.eliminaTaulesTemporals()
                        return
        
                if (self.dlg.bt_Portals.isChecked()):
                    self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: rgb(255, 170, 142)')
                    if (path != ''):
                        if versio_db == "1.0":
                            ver = "v1"
                        else:
                            ver = "v2"
                        if (os.path.exists(path + f"/tr_npolicia_{ver}.csv")):
                            trobat = False 
                            
                            arxiu = open(path + f"/tr_npolicia_{ver}.csv", 'r')
                            dummy=arxiu.readline()
                            lines = arxiu.readlines()
                            try:
                                """Creació de la taula temporal Resum_Temp_(data) de les dades del CSV de la taula resum de portals"""
                                cur.execute("CREATE TABLE \"Resum_Temp_"+Fitxer+"\" (\"NPolicia\" varchar(20), \"Habitants\" numeric);")
                                conn.commit()
                                insert=""
                                for linia in lines:
                                    vec = linia.split(';', 20 )
                                    insert += "INSERT INTO \"Resum_Temp_"+Fitxer+"\" (\"NPolicia\", \"Habitants\") VALUES ('"+ vec[0] + "', "+ vec[1]+ ");\n"
                                cur.execute(insert)
                                conn.commit()
                                #print "ok"                
                            except Exception as ex:
                                print ("I am unable to connect to the database")
                                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                                message = template.format(type(ex).__name__, ex.args)
                                print (message)
                                QMessageBox.information(None, "Error", "I am unable to connect to the database")
                                conn.rollback()
                                self.eliminaTaulesCalcul(Fitxer)
                                self.eliminaTaulesTemporals()
                    
                                self.bar.clearWidgets()
                                self.dlg.Progres.setValue(0)
                                self.dlg.Progres.setVisible(False)
                                self.dlg.lblEstatConn.setText('Connectat')
                                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                                self.dlg.setEnabled(True)
                                return
                                
                            arxiu.close()
                            arxiuLlegit = True
                        else:
                            print ("No hi ha l'arxiu")
                            path = QFileDialog.getExistingDirectory(self.dlg,"Busca la carpeta que conté els arxius provinents del mòdul TAULA RESUM",  Path_Inicial+"/",QFileDialog.ShowDirsOnly)
                    else:
                        print ("Cancelat")
                        self.bar.setEnabled(True)
                        self.bar.clearWidgets()
                        self.dlg.Progres.setVisible(False)
                        self.dlg.Progres.setValue(0)
                       
                        self.dlg.setEnabled(True)
                        self.bar.clearWidgets()
                        self.eliminaTaulesCalcul(Fitxer)
                        self.eliminaTaulesTemporals()
                        return
        else:
            a=time.time()
#       *****************************************************************************************************************
#       FI CREACIO DE LES TAULES RESUM DESDE EL CSV SUMINISTRAT 
#       *****************************************************************************************************************
        progressMessageBar = self.bar.createMessage('Processant:')
        progress = QProgressBar()
        progress.setMaximum(100)
        progress.setAlignment(Qt.AlignLeft|Qt.AlignTop)
        progressMessageBar.layout().addWidget(progress)
        #progressMessageBar.layout().addWidget(self.dlg.progress)
        self.bar.pushWidget(progressMessageBar, Qgis.Info)
        self.bar.setEnabled(False)
        progress.setValue(0)
       
        progress.setValue(10)

        self.dlg.Progres.setValue(10)
        QApplication.processEvents()
        fesCalcul = True      
        if (self.dlg.chk_poblacio.isChecked() and not arxiuLlegit):
            fesCalcul = False
        elif (self.dlg.chk_poblacio.isChecked() and arxiuLlegit):
            fesCalcul = True
        else:
            fesCalcul = True
        if not(fesCalcul):
            self.dlg.setEnabled(True)
            return
            
        if (self.dlg.lblEstatConn.text()=='Connectat'):
            self.dlg.lblEstatConn.setText('Connectat i processant')
            
            if self.dlg.tabWidget_Destino.currentIndex() == 0:
                entitat = self.dlg.comboSelPunts.currentText()
            else:
                entitat = self.dlg.comboLeyenda.currentText()
                           
            if (entitat !=""):
                uri = QgsDataSourceUri()

                try:
                    uri.setConnection(host1,port1,nomBD1,usuari1,contra1)
                    print ("Connectat")
                    #print (uri.connectionInfo())
                except Exception as ex:
                    print ("Error a la connexio")
                    template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                    message = template.format(type(ex).__name__, ex.args)
                    print (message)
                    QMessageBox.information(None, "Error", "Error a la connexio")
                    self.eliminaTaulesCalcul(Fitxer)
                    self.eliminaTaulesTemporals()
        
                    self.bar.clearWidgets()
                    self.dlg.Progres.setValue(0)
                    self.dlg.Progres.setVisible(False)
                    self.dlg.lblEstatConn.setText('Connectat')
                    self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                    self.dlg.setEnabled(True)
                    return
                                    
                
                #********************************************************************************************************
                #    Afegir l'exportació del layer, i posteriorment llençar un avis en cas de que l'entitat sigui buida 
                #********************************************************************************************************
                '''Exportar temporalment la entitat seleccionada a la BBDD'''
                layers = QgsProject.instance().mapLayers().values()
                if layers != None:
                    for layer in layers:
                        if layer.name() == self.dlg.comboLeyenda.currentText():
                            error = QgsVectorLayerExporter.exportLayer(layer, 'table="public"."LayerExportat'+Fitxer+'" (geom) '+uri.connectionInfo(), "postgres", layer.crs(), False)
                            if error[0] != 0:
                                iface.messageBar().pushMessage(u'Error', error[1])
                            
                            #cada usuari tindrà la seva taula local temporal "LayerExportat", es una versió Local Temp del Layer exportat de la leyenda.
                            #Amb l'objectiu de que dos usuaris puguin treballar amb el mateix nom de la taula, eliminant concurrencia.
                            try:
                                sql_SRID="SELECT Find_SRID('public', 'LayerExportat"+Fitxer+"', 'geom')"
                                cur.execute(sql_SRID)
                            except Exception as ex:
                                print ("ERROR SELECT SRID")
                                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                                message = template.format(type(ex).__name__, ex.args)
                                print (message)
                                QMessageBox.information(None, "Error", "ERROR SELECT SRID")
                                conn.rollback()
                                self.eliminaTaulesCalcul(Fitxer)
                                self.eliminaTaulesTemporals()
                    
                                self.bar.clearWidgets()
                                self.dlg.Progres.setValue(0)
                                self.dlg.Progres.setVisible(False)
                                self.dlg.lblEstatConn.setText('Connectat')
                                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                                self.dlg.setEnabled(True)
                                return
                            auxlist = cur.fetchall()
                            Valor_SRID=auxlist[0][0]
                            if tipus_entitat_punt:
                                alter = 'ALTER TABLE "LayerExportat'+Fitxer+'" ALTER COLUMN geom TYPE geometry(Point,'+str(Valor_SRID)+') USING ST_GeometryN(geom,1);'
                                print(Valor_SRID)
                            
                                try:
                                    cur.execute(alter)
                                    conn.commit()
                                except Exception as ex:
                                    print ("ALTER TABLE ERROR_geometry")
                                    template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                                    message = template.format(type(ex).__name__, ex.args)
                                    print (message)
                                    QMessageBox.information(None, "Error", "ALTER TABLE ERROR_geometry")
                                    conn.rollback()
                                    self.eliminaTaulesCalcul(Fitxer)
                                    self.eliminaTaulesTemporals()
                        
                                    self.bar.clearWidgets()
                                    self.dlg.Progres.setValue(0)
                                    self.dlg.Progres.setVisible(False)
                                    self.dlg.lblEstatConn.setText('Connectat')
                                    self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                                    self.dlg.setEnabled(True)
                                    return
                                
                                
                                
                            select = 'select count (*) from "LayerExportat'+Fitxer+'"'
                            
                            try:                
                                cur.execute(select)
                                auxlist = cur.fetchall()
                                if auxlist[0][0] == 0:
                                    ErrorMessage = 'La entitat escollida es buida'
                                    QMessageBox.information(None, "Error", ErrorMessage+'\n')
                                    conn.rollback()
                                    self.eliminaTaulesCalcul(Fitxer)
                                    self.eliminaTaulesTemporals()
                        
                                    self.bar.clearWidgets()
                                    self.dlg.Progres.setValue(0)
                                    self.dlg.Progres.setVisible(False)
                                    self.dlg.lblEstatConn.setText('Connectat')
                                    self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                                    self.dlg.setEnabled(True)
                                    return
                                    '''
                                    drop = 'DROP TABLE IF EXISTS "LayerExportat'+Fitxer+'"'
                                    try:
                                        cur.execute(drop)
                                        conn.commit()
                                    except Exception as ex:
                                        print ("DROP TABLE ERROR LayerExportat")
                                        template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                                        message = template.format(type(ex).__name__, ex.args)
                                        print (message)
                                        QMessageBox.information(None, "Error", errorMessage)
                                        conn.rollback()
                                        self.eliminaTaulesCalcul(Fitxer)
                                        self.eliminaTaulesTemporals()
                                    
                                    self.bar.clearWidgets()
                                    self.dlg.Progres.setValue(0)
                                    self.dlg.Progres.setVisible(False)
                                    self.dlg.lblEstatConn.setText('Connectat')
                                    self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                                    return
                                    '''
                            except Exception as ex:
                                print("ERROR select LayerExportat")
                                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                                message = template.format(type(ex).__name__, ex.args)
                                print (message)
                                QMessageBox.information(None, "Error", ErrorMessage)
                                conn.rollback()
                                self.eliminaTaulesCalcul(Fitxer)
                                self.eliminaTaulesTemporals()
                    
                                self.bar.clearWidgets()
                                self.dlg.Progres.setValue(0)
                                self.dlg.Progres.setVisible(False)
                                self.dlg.lblEstatConn.setText('Connectat')
                                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                                self.dlg.setEnabled(True)
                                return
                                
                
   
                if self.dlg.tabWidget_Destino.currentIndex() == 0:
                    sql_total="SELECT * FROM \""+self.dlg.comboSelPunts.currentText()+"\""
                else:
                    sql_total="SELECT * FROM \"LayerExportat"+Fitxer+"\""
                
                progress.setValue(30)

                self.dlg.Progres.setValue(30)
                QApplication.processEvents()
#               *****************************************************************************************************************
#               INICI CALCUL DEL GRAF I DEL BUFFER DELS TRAMS CALCULATS 
#               *****************************************************************************************************************
                if self.dlg.tabServeiRouting.currentIndex() == 0:
                    if (tipus_entitat_punt==True):
                    # XarxaCarrers = self.dlg.comboGraf.currentText()
                        XarxaCarrers = f'stretch_{Fitxer}'
                        if (self.dlg.chk_calc_local_CCU.isChecked() and self.dlg.comboMetodeTreball_CCU.currentText()=="Distancia"):
                            sql_xarxa="SELECT * FROM \"" + XarxaCarrers + "\""
                            buffer_resultat,graf_resultat,buffer_dissolved=self.calcul_graf2(sql_total,sql_xarxa,uri)
                            vlayer=buffer_resultat['OUTPUT']
                            vlayer_graf=graf_resultat['OUTPUT']
                            sql_buffer="SELECT * FROM \"buffer_final_"+Fitxer+"\""
                            error = QgsVectorLayerExporter.exportLayer(vlayer, 'table="public"."buffer_final_'+Fitxer+'" (geom) '+uri.connectionInfo(), "postgres", vlayer.crs(), False)
                            if error[0] != 0:
                                iface.messageBar().pushMessage(u'Error', error[1])

                        elif (self.dlg.chk_calc_local_CCU.isChecked() and self.dlg.comboMetodeTreball_CCU.currentText()=="Temps"):
                            sql_xarxa="SELECT * FROM \"" + XarxaCarrers + "\""
                            buffer_resultat,graf_resultat,buffer_dissolved=self.calcul_graf3(sql_total,sql_xarxa,uri)
                            vlayer=buffer_resultat['OUTPUT']
                            vlayer_graf=graf_resultat['OUTPUT']

                            #uri = "dbname='test' host=localhost port=5432 user='user' password='password' key=gid type=POINT table=\"public\".\"test\" (geom) sql="
                            # layer - QGIS vector layer
                            error = QgsVectorLayerExporter.exportLayer(vlayer, 'table="public"."buffer_final_'+Fitxer+'" (geom) '+uri.connectionInfo(), "postgres", vlayer.crs(), False)
                            if error[0] != 0:
                                iface.messageBar().pushMessage(u'Error', error[1])
                                
                            #error = QgsVectorLayerExporter.exportLayer(buffer_dissolved['OUTPUT'], 'table="public"."buffer_diss_'+Fitxer+'" (geom) '+uri.connectionInfo(), "postgres", vlayer.crs(), False)
                            #if error[0] != 0:
                            #    iface.messageBar().pushMessage(u'Error', error[1])
                                
                            sql_buffer="SELECT * FROM \"buffer_final_"+Fitxer+"\""
                        else:
                            sql_buffer=self.calcul_graf(sql_total)
                            if sql_buffer=="ERROR":
                                self.dlg.setEnabled(True)
                                return
                    else:
                        QApplication.processEvents()
                        uri.setDataSource("","("+sql_total+")","geom","","id")
                        QApplication.processEvents()
                        punts_lyr = QgsVectorLayer(uri.uri(False), "punts", "postgres")
                        QApplication.processEvents()
                        result_buffer = processing.run('native:buffer', {"INPUT": punts_lyr,
                                                                            "DISTANCE": self.dlg.Radi_CCU.text(),
                                                                            "SEGMENTS": 5,
                                                                            "END_CAP_STYLE":0,
                                                                            "JOIN_STYLE":0,
                                                                            "MITER_LIMIT":1,
                                                                            "DISSOLVE":True,
                                                                            "OUTPUT": 'memory:'})
                                                                            #"OUTPUT": 'postgres: table="public"."testpep" (geom) '+uri2.connectionInfo()})
                        #result_buffer_dissolve = processing.run('native:dissolve', {"INPUT": result_buffer['OUTPUT'],
                        #                                                            "FIELD": 'id',
                        #                                                            "OUTPUT": 'memory:'})
                        #buffer_dissolved = processing.run('native:dissolve', {"INPUT": result_buffer['OUTPUT'],
                        #                                                        "OUTPUT": 'memory:'})
                        vlayer=result_buffer['OUTPUT']
                        #vlayer=punts_lyr
                        sql_buffer="SELECT * FROM \"buffer_final_"+Fitxer+"\""
                        error = QgsVectorLayerExporter.exportLayer(vlayer, 'table="public"."buffer_final_'+Fitxer+'" (geom) '+uri.connectionInfo(), "postgres", vlayer.crs(), False)
                        if error[0] != 0:
                            iface.messageBar().pushMessage(u'Error', error[1])
                        pass
    #               *****************************************************************************************************************
    #               FI CALCUL DEL GRAF I DEL BUFFER DELS TRAMS CALCULATS 
    #               ***(**************************************************************************************************************
                    #print (sql_buffer)
                    #print("!dd")
                
                elif self.dlg.tabServeiRouting.currentIndex() == 1:
                    sql_xarxa = f"SELECT * FROM \"stretch_{Fitxer}\""
                    # Anteriorment està definit sql_total que és comboSelPunts o comboLeyenda depenent del que hagis seleccionat
                    sql_punts = f"SELECT * FROM {self.dlg.comboSelPunts.currentText()}"
                    uri.setDataSource("","("+sql_xarxa+")","geom","","id")
                    capa_xarxa = QgsVectorLayer(uri.uri(False), "xarxa", "postgres")
                    uri.setDataSource("","("+sql_total+")","geom","","id")
                    capa_punts = QgsVectorLayer(uri.uri(False), "punts", "postgres")
                    buffer_resultat,graf_resultat = self.calcul_graf_valhalla(capa_punts)
                    vlayer = buffer_resultat
                    vlayer_graf = graf_resultat
                    vlayer.startEditing()
                    idx = vlayer.fields().indexFromName('id')
                    vlayer.deleteAttribute(idx)
                    vlayer.commitChanges()
                    error = QgsVectorLayerExporter.exportLayer(vlayer, 'table="public"."buffer_final_'+Fitxer+'" (geom) '+uri.connectionInfo(), "postgres", vlayer.crs(), False)
                    if error[0] != 0:
                        iface.messageBar().pushMessage(u'Error', error[1])  
                    sql_buffer="SELECT * FROM \"buffer_final_"+Fitxer+"\""
                
                progress.setValue(60)
                self.dlg.Progres.setValue(60)
                QApplication.processEvents()
                sql_ZI=sql_buffer 
                sql_PART1_ZI=f"SELECT row_number() OVER () AS \"id\",ILL.\"cadastral_zoning_reference\",ILL.\"geom\",RS.\"Habitants\" FROM (select \"zone_{Fitxer}\".\"cadastral_zoning_reference\",\"zone_{Fitxer}\".\"geom\" from \"zone_{Fitxer}\" where \"zone_{Fitxer}\".\"id_zone\" NOT IN (select \"zone_{Fitxer}\".\"id_zone\" from \"zone_{Fitxer}\" INNER JOIN ("
                sql_TOTAL_ZI=sql_PART1_ZI+sql_ZI+f") TOT2 on ST_Intersects(\"zone_{Fitxer}\".\"geom\",TOT2.\"geom\"))) ILL JOIN \"Illes_Resum_"+Fitxer+"\" RS on (ILL.\"cadastral_zoning_reference\" = RS.\"ILLES_Codificades\")"
                if (self.dlg.chk_poblacio.isChecked()):
                    if (self.dlg.bt_ILLES.isChecked()):
                        """Si s'ha seleccionat ILLES"""
                        #sql_total="select row_number() over() as id_sql, ILLES_RESUM.\"id\",ILLES_RESUM.\"geom\",ILLES_RESUM.\"Habitants\" from (select * from \"ILLES\" INNER JOIN \"Illes_Resum_"+Fitxer+"\" ON \"ILLES\".\"D_S_I\"=\"Illes_Resum_"+Fitxer+"\".\"ILLES_Codificades\") ILLES_RESUM,\"buffer_diss_"+Fitxer+"\" where ST_DWithin(ILLES_RESUM.\"geom\",\"buffer_diss_"+Fitxer+"\".\"geom\",1)=TRUE"
                        sql_total=f"select distinct(ILLES_RESUM.\"id_zone\"),ILLES_RESUM.\"geom\",ILLES_RESUM.\"Habitants\" from (select * from \"zone_{Fitxer}\" INNER JOIN \"Illes_Resum_"+Fitxer+f"\" ON \"zone_{Fitxer}\".\"cadastral_zoning_reference\"=\"Illes_Resum_"+Fitxer+"\".\"ILLES_Codificades\") ILLES_RESUM,\"buffer_final_"+Fitxer+"\" where ST_DWithin(ILLES_RESUM.\"geom\",\"buffer_final_"+Fitxer+"\".\"geom\",1)=TRUE"
                    if (self.dlg.bt_Parcel.isChecked()):
                        """Si s'ha seleccionat PARCELES"""
                        if versio_db == '1.0':
                            sql_total=f"select distinct(PARCELES_RESUM.\"id_parcel\"),PARCELES_RESUM.\"geom\",PARCELES_RESUM.\"Habitants\" from (select * from \"parcel_temp_{Fitxer}\" INNER JOIN \"Resum_Temp_"+Fitxer+f"\" ON \"parcel_temp_{Fitxer}\".\"cadastral_reference\"=\"Resum_Temp_"+Fitxer+"\".\"Parcela\") PARCELES_RESUM,\"buffer_final_"+Fitxer+"\" where ST_DWithin(PARCELES_RESUM.\"geom\",\"buffer_final_"+Fitxer+"\".\"geom\",1)=TRUE"
                        else:
                            sql_total="select distinct(PARCELES_RESUM.\"id_parcel\"),PARCELES_RESUM.\"geom\",PARCELES_RESUM.\"Habitants\" from (select * from \"parcel\" INNER JOIN \"Resum_Temp_"+Fitxer+"\" ON \"parcel\".\"cadastral_reference\"=\"Resum_Temp_"+Fitxer+"\".\"Parcela\") PARCELES_RESUM,\"buffer_final_"+Fitxer+"\" where ST_DWithin(PARCELES_RESUM.\"geom\",\"buffer_final_"+Fitxer+"\".\"geom\",1)=TRUE"
                        
                    if (self.dlg.bt_Portals.isChecked()):
                        """Si s'ha seleccionat PORTALS"""
                        sql_total=f"select distinct(PORTALS_RESUM.\"id_address\"),PORTALS_RESUM.\"geom\",PORTALS_RESUM.\"Habitants\" from (select * from \"address_{Fitxer}\" INNER JOIN \"Resum_Temp_"+Fitxer+f"\" ON \"address_{Fitxer}\".\"designator\"=\"Resum_Temp_"+Fitxer+"\".\"NPolicia\") PORTALS_RESUM,\"buffer_final_"+Fitxer+"\" where ST_DWithin(PORTALS_RESUM.\"geom\",\"buffer_final_"+Fitxer+"\".\"geom\",1)=TRUE"
                        
    #               *****************************************************************************************************************
    #               INICI CARREGA DE LES ILLES, PARCELES O PORTALS QUE QUEDEN AFECTATS PEL BUFFER DEL GRAF 
    #               *****************************************************************************************************************
    #                uri.setDataSource("","("+sql_total+")","geom","","id")
                    QApplication.processEvents()
                    #uri.setDataSource("","("+sql_total+")",geometria,"","id_sql")
                    if self.dlg.bt_ILLES.isChecked():
                        uri.setDataSource("","("+sql_total+")","geom","","id_zone")
                    if self.dlg.bt_Parcel.isChecked():
                        uri.setDataSource("","("+sql_total+")","geom","","id_parcel")
                    if self.dlg.bt_Portals.isChecked():
                        uri.setDataSource("","("+sql_total+")","geom","","id_address")
                    QApplication.processEvents()
                    
                    titol=self.dlg.TB_titol.text().replace("'","\'")
                    titol2='Cobertura de '
                    titol3=titol2.encode('utf8','strict')+titol.encode('utf8','strict')
                    vlayer = QgsVectorLayer(uri.uri(), titol3.decode('utf8'), "postgres")
                    QApplication.processEvents()
                    if vlayer.isValid():
                        Cobertura=datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
                        """Es crea un Shape a la carpeta temporal amb la data i hora actual"""
                        if (qgis.utils.Qgis.QGIS_VERSION_INT>=31004):
                            save_options = QgsVectorFileWriter.SaveVectorOptions()
                            save_options.driverName = "ESRI Shapefile"
                            save_options.fileEncoding = "UTF-8"
                            transform_context = QgsProject.instance().transformContext()
                            error=QgsVectorFileWriter.writeAsVectorFormatV2(vlayer, TEMPORARY_PATH+"/Cobertura_"+Cobertura+".shp",transform_context,save_options)
                        else:
                            #error=QgsVectorFileWriter.writeAsVectorFormat(vlayer, TEMPORARY_PATH+"/Cobertura_"+Cobertura+".shp", "utf-8", vlayer.crs(), "ESRI Shapefile")
                            error=QgsVectorFileWriter.writeAsVectorFormat(vlayer, TEMPORARY_PATH+"/Cobertura_"+Cobertura+".shp", "utf-8", Valor_SRID, "ESRI Shapefile")

                        """Es carrega el Shape a l'entorn del QGIS"""
                        vlayer = QgsVectorLayer(TEMPORARY_PATH+"/Cobertura_"+Cobertura+".shp", titol3.decode('utf8'), "ogr")
                        symbols = vlayer.renderer().symbols(QgsRenderContext())
                        symbol=symbols[0]
                        symbol.setColor(self.dlg.color.palette().color(1))
                        QgsProject.instance().addMapLayer(vlayer,False)
                        root = QgsProject.instance().layerTreeRoot()
                        myLayerNode=QgsLayerTreeLayer(vlayer)
                        root.insertChildNode(0,myLayerNode)
                        #root.insertLayer(0,vlayer)
                        myLayerNode.setCustomProperty("showFeatureCount", True)
                        iface.mapCanvas().refresh()
                        #qgis.utils.iface.legendInterface().refreshLayerSymbology(vlayer)
                    else:
                        print("error Cobertura")
                    progress.setValue(70)
                    self.dlg.Progres.setValue(70)
                    QApplication.processEvents()
    #               *****************************************************************************************************************
    #               FI CARREGA DE LES ILLES, PARCELES O PORTALS QUE QUEDEN AFECTATS PEL BUFFER DEL GRAF 
    #               *****************************************************************************************************************
                    
    #               *****************************************************************************************************************
    #               INICI CARREGA DEL TEMATIC DE POBLACIO NO AFECTADA  
    #               *****************************************************************************************************************
                    """ Calcul dels habitants afectats"""
                    sql = "SELECT SUM(SUMA.\"Habitants\") from ("+sql_total+") SUMA"
                    #print (sql)
                    try:
                        cur.execute(sql)
                        Habitants_afectats = cur.fetchone()
                    except Exception as ex:
                        print ("Error SELECT suma habitants")
                        template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                        message = template.format(type(ex).__name__, ex.args)
                        print (message)
                        QMessageBox.information(None, "Error", "Error SELECT suma habitants")
                        conn.rollback()
                        self.eliminaTaulesCalcul(Fitxer)
                        self.eliminaTaulesTemporals()
                        self.bar.clearWidgets()
                        self.dlg.Progres.setValue(0)
                        self.dlg.Progres.setVisible(False)
                        self.dlg.lblEstatConn.setText('Connectat')
                        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                        self.dlg.setEnabled(True)
                        return
                    """Calcul dels habitants totals"""
                    if (self.dlg.bt_ILLES.isChecked()):
                        sql = "SELECT SUM(SUMA.\"Habitants\") from (SELECT \"Habitants\" from \"Illes_Resum_"+Fitxer+"\") SUMA"
                    else:
                        sql = "SELECT SUM(SUMA.\"Habitants\") from (SELECT \"Habitants\" from \"Resum_Temp_"+Fitxer+"\") SUMA"
                    try:
                        cur.execute(sql)
                        Habitants_totals = cur.fetchone()
                    except Exception as ex:
                        print ("Error SELECT Suma")
                        template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                        message = template.format(type(ex).__name__, ex.args)
                        print (message)
                        QMessageBox.information(None, "Error", "Error SELECT Suma")
                        conn.rollback()
                        self.eliminaTaulesCalcul(Fitxer)
                        self.eliminaTaulesTemporals()
                        self.bar.clearWidgets()
                        self.dlg.Progres.setValue(0)
                        self.dlg.Progres.setVisible(False)
                        self.dlg.lblEstatConn.setText('Connectat')
                        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                        self.dlg.setEnabled(True)
                        return
                    self.dlg.lblNum.setText(str("{0:.2f}%".format(Habitants_afectats[0]/Habitants_totals[0]*100)))
                    print ("HABITANTS AFECTATS: "+str(Habitants_afectats[0]))
                    print ("HABITANTS TOTALS: "+str(Habitants_totals[0]))
                    if (self.dlg.checkBoxPoblacioNoAfectada.isChecked()):
                        """Creació del tematic de població no afectada"""
                        uri.setDataSource("","("+sql_TOTAL_ZI+")","geom","","id")
                        titol=self.dlg.TB_titol.text().replace("'","\'")
                        titol2='Temàtic de població no afectada: '
                        titol3=titol2.encode('utf8','strict')+titol.encode('utf8','strict')
                        vlayer = QgsVectorLayer(uri.uri(), titol3.decode('utf8'), "postgres")
                        if vlayer.isValid():
                            Tematic=datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
                            """Es crea un Shape a la carpeta temporal amb la data i hora actual"""
                            if (qgis.utils.Qgis.QGIS_VERSION_INT>=31004):
                                save_options = QgsVectorFileWriter.SaveVectorOptions()
                                save_options.driverName = "ESRI Shapefile"
                                save_options.fileEncoding = "UTF-8"
                                transform_context = QgsProject.instance().transformContext()
                                error=QgsVectorFileWriter.writeAsVectorFormatV2(vlayer, TEMPORARY_PATH+"/Tematic_"+Tematic+".shp",transform_context,save_options)
                            else:
                                error=QgsVectorFileWriter.writeAsVectorFormat(vlayer, TEMPORARY_PATH+"/Tematic_"+Tematic+".shp", "utf-8", vlayer.crs(), "ESRI Shapefile")
                            """Es carrega el Shape a l'entorn del QGIS"""
                            vlayer = QgsVectorLayer(TEMPORARY_PATH+"/Tematic_"+Tematic+".shp", titol3.decode('utf8'), "ogr")
                            vlayer.setProviderEncoding(u'UTF-8')
                            vlayer.dataProvider().setEncoding(u'UTF-8')
                            '''
                            cur.execute("DROP TABLE IF EXISTS \"Illes_Resum_"+Fitxer+"\"")
                            conn.commit()
                            
                            cur.execute("DROP TABLE IF EXISTS \"Resum_Temp_"+Fitxer+"\"")
                            conn.commit()                        
                            '''
                            fieldname="Habitants"
                            numberOfClasses=5
                            myRangeList=[]
                            mysymbol=QgsFillSymbol()
                            colorRamp=QgsGradientColorRamp( QColor( 230, 230, 230 ), QColor( 60, 60, 60 ))
                            
                            format = QgsRendererRangeLabelFormat()
                            template = "%1 a %2 habitants"
                            precision = 0
                            format.setFormat(template)
                            format.setPrecision(precision)
                            format.setTrimTrailingZeroes(True)
                            renderer=QgsGraduatedSymbolRenderer.createRenderer(vlayer,fieldname,numberOfClasses,QgsGraduatedSymbolRenderer.Quantile,mysymbol,colorRamp)
                            renderer.setLabelFormat(format,True)
                            vlayer.setRenderer(renderer)
                            
                            QgsProject.instance().addMapLayer(vlayer,False)
                            root = QgsProject.instance().layerTreeRoot()
                            myLayerNode=QgsLayerTreeLayer(vlayer)
                            root.insertChildNode(0,myLayerNode)
                            myLayerNode.setCustomProperty("showFeatureCount", True)
                            iface.mapCanvas().refresh()
                            #qgis.utils.iface.legendInterface().refreshLayerSymbology(vlayer)
                        else:
                            QMessageBox.information(None, "LAYER ERROR 1:", "%s\n\nThe layer %s is not valid" % ("error","nom_layer"))
                progress.setValue(80)
                self.dlg.Progres.setValue(80)
                QApplication.processEvents()
#               *****************************************************************************************************************
#               FI CARREGA DEL TEMATIC DE POBLACIO NO AFECTADA  
#               *****************************************************************************************************************
                
#               *****************************************************************************************************************
#               INICI CARREGA DE LA COBERTURA DEL BUFFER DEL GRAF  
#               *****************************************************************************************************************
                if self.dlg.tabServeiRouting.currentIndex() == 0:
                    if (self.dlg.chk_calc_local_CCU.isChecked()): # and self.dlg.comboMetodeTreball_CCU.currentText()=="Distancia"):
                        sql_total1="SELECT * FROM Buffer_Final_"+Fitxer
                    else:
                        sql_total1="SELECT row_number() OVER () AS \"id\",\"punt_id\",\"geom\" FROM Buffer_Final_"+Fitxer
                elif self.dlg.tabServeiRouting.currentIndex() == 1:
                    sql_total1 = f"SELECT * FROM \"buffer_final_{Fitxer}\""

                """ Creació del tematic del buffer"""
                uri.setDataSource("","("+sql_total1+")","geom","","id")
                titol=self.dlg.TB_titol.text().replace("'","\'")
                titol2='ZI: '
                titol3=titol2.encode('utf8','strict')+titol.encode('utf8','strict')
                vlayer = QgsVectorLayer(uri.uri(), titol3.decode('utf8'), "postgres")
                if vlayer.isValid():
                    Area=datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
                    """Es crea un Shape a la carpeta temporal amb la data i hora actual"""
                    if (qgis.utils.Qgis.QGIS_VERSION_INT>=31004):
                        save_options = QgsVectorFileWriter.SaveVectorOptions()
                        save_options.driverName = "ESRI Shapefile"
                        save_options.fileEncoding = "UTF-8"
                        transform_context = QgsProject.instance().transformContext()
                        error=QgsVectorFileWriter.writeAsVectorFormatV2(vlayer, TEMPORARY_PATH+"/Area_"+Area+".shp", transform_context,save_options)
                    else:
                        error=QgsVectorFileWriter.writeAsVectorFormat(vlayer, TEMPORARY_PATH+"/Area_"+Area+".shp", "utf-8", vlayer.crs(), "ESRI Shapefile")
                    vlayer=None
                    """Es carrega el Shape a l'entorn del QGIS"""
                    vlayer = QgsVectorLayer(TEMPORARY_PATH+"/Area_"+Area+".shp", titol3.decode('utf8'), "ogr")
                    vlayer.setProviderEncoding(u'UTF-8')
                    vlayer.dataProvider().setEncoding(u'UTF-8')
                    symbols = vlayer.renderer().symbols(QgsRenderContext())
                    symbol=symbols[0]
                    symbol.setColor(self.dlg.colorArea.palette().color(1))
                    vlayer.setOpacity(0.4)
                    QgsProject.instance().addMapLayer(vlayer,False)
                    root = QgsProject.instance().layerTreeRoot()
                    myLayerNode=QgsLayerTreeLayer(vlayer)
                    root.insertChildNode(0,myLayerNode)
                    myLayerNode.setCustomProperty("showFeatureCount", True)
                    iface.mapCanvas().refresh()
                    #iface.legendInterface().refreshLayerSymbology(vlayer)

                else:
                    print("error ZI:")

                progress.setValue(90)
                self.dlg.Progres.setValue(90)
                QApplication.processEvents()
#               *****************************************************************************************************************
#               FI CARREGA DE LA COBERTURA DEL BUFFER DEL GRAF  
#               *****************************************************************************************************************
                
#               *****************************************************************************************************************
#               INICI CARREGA DEL GRAF  
#               *****************************************************************************************************************
                if (self.dlg.checkBoxDibuix.isChecked()):
                    """ Creació del tematic del graf"""
                    titol=self.dlg.TB_titol.text().replace("'","\'")
                    titol2='Graf: '
                    titol3=titol2.encode('utf8','strict')+titol.encode('utf8','strict')
                    #vlayer = QgsVectorLayer(uri.uri(), titol3.decode('utf8'), "postgres")
                    if (self.dlg.chk_calc_local_CCU.isChecked()):# and self.dlg.comboMetodeTreball_CCU.currentText()=="Distancia"):
                        vlayer=vlayer_graf
                    else:
                        uri.setDataSource("","(SELECT * FROM Graf_utilitzat_"+Fitxer+")","geom","","id")
                        vlayer = QgsVectorLayer(uri.uri(), titol3.decode('utf8'), "postgres")
                    if self.dlg.tabServeiRouting.currentIndex() == 1:
                        alg_params = {
                        'FIELD' : ['entity_id'],
                        'INPUT': vlayer,
                        'SEPARATE_DISJOINT' : False,
                        'OUTPUT': 'TEMPORARY_OUTPUT'
                        }
                        vlayer = processing.run('native:dissolve', alg_params)['OUTPUT']

                    if vlayer.isValid():
                        Graf=datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
                        """Es crea un Shape a la carpeta temporal amb la data i hora actual"""
                        if (qgis.utils.Qgis.QGIS_VERSION_INT>=31004):
                            save_options = QgsVectorFileWriter.SaveVectorOptions()
                            save_options.driverName = "ESRI Shapefile"
                            save_options.fileEncoding = "UTF-8"
                            transform_context = QgsProject.instance().transformContext()
                            error=QgsVectorFileWriter.writeAsVectorFormatV2(vlayer, TEMPORARY_PATH+"/Graf_"+Graf+".shp",transform_context,save_options)
                        else:
                            error=QgsVectorFileWriter.writeAsVectorFormat(vlayer, TEMPORARY_PATH+"/Graf_"+Graf+".shp", "utf-8", vlayer.crs(), "ESRI Shapefile")
                        """Es carrega el Shape a l'entorn del QGIS"""
                        vlayer = QgsVectorLayer(TEMPORARY_PATH+"/Graf_"+Graf+".shp", titol3.decode('utf8'), "ogr")
                        vlayer.setProviderEncoding(u'UTF-8')
                        vlayer.dataProvider().setEncoding(u'UTF-8')
                        #cur.execute("DROP TABLE IF EXISTS Graf_utilitzat_"+Fitxer)
                        #conn.commit()

                        symbols = vlayer.renderer().symbols(QgsRenderContext())
                        symbol=symbols[0]
                        symbol.setColor(self.dlg.color.palette().color(1))
                        if (self.dlg.comboTras.currentText()=='Estret'):
                            symbol.setWidth(0.5)
                        if (self.dlg.comboTras.currentText()=='Mitjà'):
                            symbol.setWidth(1.0)
                        if (self.dlg.comboTras.currentText()=='Ample'):
                            symbol.setWidth(1.5)
                        QgsProject.instance().addMapLayer(vlayer,False)
                        root = QgsProject.instance().layerTreeRoot()
                        myLayerNode=QgsLayerTreeLayer(vlayer)
                        root.insertChildNode(0,myLayerNode)
                        myLayerNode.setCustomProperty("showFeatureCount", True)
                        iface.mapCanvas().refresh()
                        #qgis.utils.iface.legendInterface().refreshLayerSymbology(vlayer)
                    else:
                        QMessageBox.information(None, "LAYER ERROR 3:", "%s\n\nThe layer %s is not valid" % ("error","nom_layer"))
                
                progress.setValue(0)
                self.bar.clearWidgets()
                self.dlg.Progres.setValue(0)
                self.dlg.Progres.setVisible(False)
                QApplication.processEvents()
#               *****************************************************************************************************************
#               FI CARREGA DEL GRAF  
#               *****************************************************************************************************************

            else:
                QMessageBox.information(None, 'Informació:', 'No hi ha cap element seleccionat')
                
        else:
            QMessageBox.information(None, 'Informació:', 'No està connectat a cap base de dades')

        self.eliminaTaulesCalcul(Fitxer)
        self.eliminaTaulesTemporals()
        
        
        nom_conn=self.dlg.comboConnexio.currentText()
        select = 'Selecciona connexió'
        if nom_conn==select:
            self.dlg.lblEstatConn.setText('No connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #FFFFFF')
        else:
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
        print ("Durada: "+str(int(time.time()-a))+" s.")
        self.bar.setEnabled(True)
        self.bar.clearWidgets()
        self.dlg.Progres.setVisible(False)
        self.dlg.Progres.setValue(0)
        self.dlg.setEnabled(True)              
        QApplication.processEvents()
    
    
    
    def eliminaTaulesCalcul(self,Fitxer):
        global cur
        global conn
        '''
        Aquesta funció s'encarrega d'eliminar les taules utilitzades durant el càlcul
        '''   
        drop = ''  
        drop += 'DROP TABLE IF EXISTS "buffer_final_'+Fitxer+'";\n'
        drop += 'DROP TABLE IF EXISTS "Illes_Resum_'+Fitxer+'";\n'
        drop += 'DROP TABLE IF EXISTS "LayerExportat'+Fitxer+'";\n'
        drop += 'DROP TABLE IF EXISTS "Graf_utilitzat_'+Fitxer+'";\n'
        drop += 'DROP TABLE IF EXISTS "Resum_Temp_'+Fitxer+'";\n'
        drop += 'drop table if exists "Graf_utilitzat_'+Fitxer+'";\n'
        try:
            cur.execute(drop)
            conn.commit()
        except Exception as ex:
            print("Error DROP final")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error DROP final")
            conn.rollback()
            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
    
    
    
    def calcul_graf2(self,sql_punts,sql_xarxa,uri2):
        #               *****************************************************************************************************************
        #               INICI CARREGA DE LES ILLES, PARCELES O PORTALS QUE QUEDEN AFECTATS PEL BUFFER DEL GRAF 
        #               *****************************************************************************************************************
        #                uri.setDataSource("","("+sql_total+")","geom","","id")
        print("local i distancia")

        QApplication.processEvents()
        uri2.setDataSource("","("+sql_punts+")","geom","","id")
        QApplication.processEvents()
        punts_lyr = QgsVectorLayer(uri2.uri(False), "punts", "postgres")
        QApplication.processEvents()
        uri2.setDataSource("","("+sql_xarxa+")","geom","","id")
        QApplication.processEvents()
        network_lyr = QgsVectorLayer(uri2.uri(False), "xarxa", "postgres")
        QApplication.processEvents()
        #if (punts_lyr.isValid() and network_lyr.isValid()):
        parameters = {'INPUT': network_lyr,
                      'START_POINTS': punts_lyr,
                      'STRATEGY': 0,
                      'TRAVEL_COST2':self.dlg.TL_Dist_Cost_CCU.text(),
                      'DIRECTION_FIELD': '',
                      'VALUE_FORWARD': '',
                      'VALUE_BACKWARD': '',
                      'VALUE_BOTH': '',
                      'DEFAULT_DIRECTION': 2,
                      'SPEED_FIELD': '',
                      'DEFAULT_SPEED': 1,
                      'TOLERANCE': 0,
                      'INCLUDE_BOUNDS': 0,
                      'OUTPUT_LINES': 'memory:',
                      'OUTPUT': 'memory:'}
        linias_graf = processing.run('qgis:serviceareafromlayer', parameters)
        #result_buffer = processing.run('native:buffer', {"INPUT": network_lyr,
        # native:dissolve
        result_dissolve = processing.run('native:dissolve', {"INPUT": linias_graf['OUTPUT_LINES'],
                                                             "FIELD": 'id',
                                                             "OUTPUT": 'memory:'})        

        result_singleparts = processing.run('native:multiparttosingleparts', {"INPUT": linias_graf['OUTPUT_LINES'],
                                                                              "OUTPUT": 'memory:'})
        result_buffer = processing.run('native:buffer', {"INPUT": result_singleparts['OUTPUT'],
                                                         "DISTANCE": 20,
                                                         "SEGMENTS": 5,
                                                         "END_CAP_STYLE":0,
                                                         "JOIN_STYLE":0,
                                                         "MITER_LIMIT":1,
                                                         "DISSOLVE":0,
                                                         "OUTPUT": 'memory:'})
                                                         #"OUTPUT": 'postgres: table="public"."testpep" (geom) '+uri2.connectionInfo()})
        
        result_buffer_dissolve = processing.run('native:dissolve', {"INPUT": result_buffer['OUTPUT'],
                                                                    "FIELD": 'id',
                                                                    "OUTPUT": 'memory:'})
        
        buffer_dissolved = processing.run('native:dissolve', {"INPUT": result_buffer['OUTPUT'],
                                                             "OUTPUT": 'memory:'})        
        
        return result_buffer_dissolve,result_dissolve,buffer_dissolved
    
    def troba_distancia(self,linea,punt):
        distancia=linea.geometry().lineLocatePoint(punt.geometry())
        return distancia
    def troba_posicio(self,id,llista_id):
        resultat=[]
        for j,x in enumerate(llista_id):
            #print (x)
            if id==x:
                #print ("id:"+str(id))
                resultat.append(j)
        return resultat
        
    def calcula_distancies(self,linea,posicio,punts):
        resultat=[]
        for i in range(len(posicio)):
            #print (posicio[i])
            resultat.append([posicio[i],self.troba_distancia(linea,punts[posicio[i]])])
        resultat=sorted(resultat, key=lambda x: x[1])
        return resultat
    
    def Calcula_VEL_KMH(self,xarxa,crs,uri):
         # Invertir dirección de línea
        alg_params = {
        'INPUT': xarxa,
        'OUTPUT': 'memory:'
        }
        outputs={}
        outputs['InvertirDireccinDeLnea'] = processing.run('native:reverselinedirection', alg_params)
        
        if (self.dlg.chk_CostInvers_CCU.isChecked()):

            # VEL_PS=0
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'speed',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '0*0',
                'INPUT': outputs['InvertirDireccinDeLnea']['OUTPUT'],
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
            outputs['Vel_ps0'] = processing.run('qgis:fieldcalculator', alg_params)
    
            # VEL_PS_INV=0
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'reverse_speed',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '0*0',
                'INPUT': xarxa,
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
            outputs['Vel_ps_inv0'] = processing.run('qgis:fieldcalculator', alg_params)
        
           # CREACIO_VEL_KMH_INV
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'VEL_KMH',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '\"reverse_speed\"*60/1000',
                'INPUT': outputs['Vel_ps0']['OUTPUT'],
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
            outputs['Creacio_vel_kmh_inv'] = processing.run('qgis:fieldcalculator', alg_params)
        
            # CREACIO_VEL_KMH_DIREC
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'VEL_KMH',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': 'speed*60/1000',
                'INPUT': outputs['Vel_ps_inv0']['OUTPUT'],
                'NEW_FIELD': True,
                'OUTPUT': 'memory:'
            }
            outputs['Creacio_vel_kmh_direc'] = processing.run('qgis:fieldcalculator', alg_params)
                    
        else:
            # VEL_PS=0
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'reverse_speed',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '0*0',
                'INPUT': outputs['InvertirDireccinDeLnea']['OUTPUT'],
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
            outputs['Vel_ps0'] = processing.run('qgis:fieldcalculator', alg_params)
    
            # VEL_PS_INV=0
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'reverse_speed',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '0*0',
                'INPUT': xarxa,
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
            outputs['Vel_ps_inv0'] = processing.run('qgis:fieldcalculator', alg_params)
        
           # CREACIO_VEL_KMH_INV
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'VEL_KMH',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '\"speed\"*60/1000',
                'INPUT': outputs['Vel_ps0']['OUTPUT'],
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
        
            # CREACIO_VEL_KMH_DIREC
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'VEL_KMH',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': 'speed*60/1000',
                'INPUT': outputs['Vel_ps_inv0']['OUTPUT'],
                'NEW_FIELD': True,
                'OUTPUT': 'memory:'
            }
            outputs['Creacio_vel_kmh_direc'] = processing.run('qgis:fieldcalculator', alg_params)
        
        # Unir capas vectoriales
        alg_params = {
            'CRS': QgsCoordinateReferenceSystem('EPSG:'+str(crs)),
            'LAYERS': [outputs['Creacio_vel_kmh_direc']['OUTPUT'],outputs['Creacio_vel_kmh_inv']['OUTPUT']],
            'OUTPUT': 'memory:'
        }
        outputs['UnirCapasVectoriales'] = processing.run('native:mergevectorlayers', alg_params)
    
        # DIRECCIO
        alg_params = {
            'FIELD_LENGTH': 10,
            'FIELD_NAME': 'DIRECCIO',
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 2,
            'FORMULA': '\'D\'',
            'INPUT': outputs['UnirCapasVectoriales']['OUTPUT'],
            'NEW_FIELD': True,
            'OUTPUT': 'memory:'
        }
        outputs['Direccio'] = processing.run('qgis:fieldcalculator', alg_params)

        if (self.dlg.chk_CostNusos_CCU.isChecked()):
            # CREACIO_L_TRAM_TEMP
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'L_TRAM_TEMP',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '$length',
                'INPUT': outputs['Direccio']['OUTPUT'],
                'NEW_FIELD': True,
                'OUTPUT': 'memory:'
            }
            outputs['Direccio'] = processing.run('qgis:fieldcalculator', alg_params)        
        return outputs['Direccio']['OUTPUT']
                
        #print (outputs)
    
    def calcul_graf3(self,sql_punts,sql_xarxa,uri2):
        #               *****************************************************************************************************************
        #               INICI CARREGA DE LES ILLES, PARCELES O PORTALS QUE QUEDEN AFECTATS PEL BUFFER DEL GRAF 
        #               *****************************************************************************************************************
        #                uri.setDataSource("","("+sql_total+")","geom","","id")
        global Fitxer
        print("local i temps")

        QApplication.processEvents()
        uri2.setDataSource("","("+sql_punts+")","geom","","id")
        QApplication.processEvents()
        punts_lyr = QgsVectorLayer(uri2.uri(False), "punts", "postgres")
        QApplication.processEvents()
        uri2.setDataSource("","("+sql_xarxa+")","geom","","id")
        QApplication.processEvents()
        network_lyr = QgsVectorLayer(uri2.uri(False), "xarxa", "postgres")
        QApplication.processEvents()
        #if (punts_lyr.isValid() and network_lyr.isValid()):
        #************************************************************************************
        #************************************************************************************
        outputs = {}
        epsg = network_lyr.crs().postgisSrid()
        
        alg_params = {
            'INPUT': punts_lyr,
            'OPERATION': '',
            'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:'+str(epsg)),
            'OUTPUT': 'memory:'
        }
        outputs['ReproyectarCapa'] = processing.run('native:reprojectlayer', alg_params)
        
        #p_lyr = punts_lyr 
        p_lyr = outputs['ReproyectarCapa']['OUTPUT']
        graf = network_lyr
        

        l_lyr=self.Calcula_VEL_KMH(graf,epsg,uri2)
        
        #QgsProject.instance().addMapLayer(l_lyr)
        
        
        lines_features = [ line_feature for line_feature in l_lyr.getFeatures() ] 
        points_features = [ point_feature for point_feature in p_lyr.getFeatures() ]
        vl = QgsVectorLayer("LineString?crs=epsg:" + str(epsg), "Lineas2", "memory")
        pr = vl.dataProvider()
        lista=[]
        for field in lines_features[0].fields():
            lista.append(field)
        
        #print (lista)
        pr.addAttributes(lista)
            
        vl.updateFields()
        feats = []
        puntos=[]
        idx_lines=[]
        punts_id=[]
        Trams0_id=[]
        Trams1_id=[]
        Trams_id=[]
        repetits=[]
        for p in points_features:
            lineas=[]
            for l in lines_features:
                lineas.append([l.geometry().closestSegmentWithContext( p.geometry().asPoint() )])
            punts_id.append(min(lineas)[0][1])
            Trams0_id.append(lineas.index(sorted(lineas)[0])+1)
            Trams1_id.append(lineas.index(sorted(lineas)[1])+1)
        Trams_id.append([0,Trams0_id])
        Trams_id.append([1,Trams1_id])
        #print(Trams0_id)
        #print(Trams1_id)
        #print(Trams_id)
        #print(Trams_id[0][1])
        #print(Trams_id[1][1])
        
        repetits.append([x for x, y in collections.Counter(Trams_id[0][1]).items() if y > 1])
        repetits.append([x for x, y in collections.Counter(Trams_id[1][1]).items() if y > 1])
        #print(repetits)
        
        trams_fets=[]
        feat_temp = QgsFeature()
        for index_punt,p in enumerate(points_features):
            #print(index_punt)
            #print (repetits)
            for i in range(2):
                linea_cut=lines_features[Trams_id[i][1][index_punt]-1]
                if ([linea_cut.id()]) not in repetits:
                    idx_lines.append(linea_cut.id())
        
                    start=0
                    distancia=round(self.troba_distancia(linea_cut,p),3)
                    longitud=round(linea_cut.geometry().length(),3)
                    lp=linea_cut.geometry().constGet()
                    newgeom=QgsGeometry(lp.curveSubstring(start,distancia))
                    #print(newgeom)
                    f=QgsFeature()
                    f.setAttributes(linea_cut.attributes())
                    f.setGeometry(newgeom)
                    feats.append(f)
        
                    newgeom=QgsGeometry(lp.curveSubstring(distancia,longitud))
                    #print(newgeom)
                    f=QgsFeature()
                    f.setAttributes(linea_cut.attributes())
                    f.setGeometry(newgeom)
                    feats.append(f)
                else:
                    #print("REPE")
                    #break
                    id_tram_Read=linea_cut.id()
                    if id_tram_Read not in trams_fets:
                        trams_fets.append(id_tram_Read)
        
                        idx_lines.append(id_tram_Read)
                        posicio=self.troba_posicio(linea_cut.id(),Trams_id[i][1])
                        llista_dist=self.calcula_distancies(linea_cut,posicio,points_features)
                        #En llista_dist estan ordenat de menor distancia a major distancia
                        
                        #break
                        start=0
                        #distancia=troba_distancia(linea_cut,p)
                        longitud=round(linea_cut.geometry().length(),3)
                        #print (longitud)
                        lp=linea_cut.geometry().constGet()
                        for x in range(len(posicio)):
                            if x==0:
                                start=0
                            else:
                                start=round(llista_dist[x-1][1],3)
                            
                            distancia=round(llista_dist[x][1],3)
        
                            newgeom=QgsGeometry(lp.curveSubstring(start,distancia))
                            f=QgsFeature()
                            f.setAttributes(linea_cut.attributes())
                            f.setGeometry(newgeom)
                            feats.append(f)
        
                        newgeom=QgsGeometry(lp.curveSubstring(distancia,longitud))
                        f=QgsFeature()
                        f.setAttributes(linea_cut.attributes())
                        f.setGeometry(newgeom)
                        feats.append(f)
                        
                    #for x in range(Trams_id[i][1].count(lines_features[Trams_id[i][1][p.id()-1]-1].id())):
                        
            minDistPoint = punts_id[index_punt]
            punto = QgsFeature()
            punto.setGeometry(QgsGeometry.fromPointXY(minDistPoint))
        
            punto.setAttributes([points_features.index(p),123])
            puntos.append(punto)
            #print (trams_fets)
        for current,feat_item in enumerate(lines_features):
            if (current+1) not in idx_lines:
                feats.append(feat_item)
        pr.addFeatures(feats)
        vl.updateExtents()
        #QgsProject.instance().addMapLayer(vl)
        #outputs={}
        
        if (self.dlg.chk_CostNusos_CCU.isChecked()):

            # AFEGIR COST DE SEMAFORS A VEL_KMH
            #print("entra")
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'VEL_KMH',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '($length /(($length/((\"speed\"+\"reverse_speed\")))+(\"total_cost_semaphore\"*($length/\"L_TRAM_TEMP\"))))*60/1000',
                'INPUT': vl,
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
                #'OUTPUT': 'postgres: table="public"."testpep" (geom) '+uri.connectionInfo()
            }
            outputs['vel_kmh_amb_sem'] = processing.run('qgis:fieldcalculator', alg_params)
            layer=outputs['vel_kmh_amb_sem']['OUTPUT']
        else:
            layer=vl

        # AreaServei
        alg_params = {
            'DEFAULT_DIRECTION': 0,
            'DEFAULT_SPEED': 50,
            'DIRECTION_FIELD': 'DIRECCIO',
            'INCLUDE_BOUNDS': False,
            'INPUT':layer,
            'SPEED_FIELD': 'VEL_KMH',
            'START_POINTS': p_lyr,
            'STRATEGY': 1,
            'TOLERANCE': 0.1,
            'TRAVEL_COST2': str(float(self.dlg.TL_Dist_Cost_CCU.text())/60),
            'VALUE_BACKWARD': '',
            'VALUE_BOTH': '',
            'VALUE_FORWARD': 'D',
            'OUTPUT_LINES':'memory:'
        }
        outputs['Areaservei'] = processing.run('qgis:serviceareafromlayer', alg_params)
#         parameters = {'INPUT': network_lyr,
#                       'START_POINTS': punts_lyr,
#                       'STRATEGY': 0,
#                       'TRAVEL_COST':self.dlg.TL_Dist_Cost_CCU.text(),
#                       'DIRECTION_FIELD': '',
#                       'VALUE_FORWARD': '',
#                       'VALUE_BACKWARD': '',
#                       'VALUE_BOTH': '',
#                       'DEFAULT_DIRECTION': 2,
#                       'SPEED_FIELD': '',
#                       'DEFAULT_SPEED': 1,
#                       'TOLERANCE': 0,
#                       'INCLUDE_BOUNDS': 0,
#                       'OUTPUT_LINES': 'memory:',
#                       'OUTPUT': 'memory:'}
#         linias_graf = processing.run('qgis:serviceareafromlayer', parameters)
        
        #************************************************************************************
        #************************************************************************************
        #result_buffer = processing.run('native:buffer', {"INPUT": network_lyr,
        # native:dissolve
        result_dissolve = processing.run('native:dissolve', {"INPUT": outputs['Areaservei']['OUTPUT_LINES'],
                                                             "FIELD": 'id',
                                                             "OUTPUT": 'memory:'})        

        result_singleparts = processing.run('native:multiparttosingleparts', {"INPUT": outputs['Areaservei']['OUTPUT_LINES'],
                                                                              "OUTPUT": 'memory:'})
        result_buffer = processing.run('native:buffer', {"INPUT": result_singleparts['OUTPUT'],
                                                         "DISTANCE": 20,
                                                         "SEGMENTS": 5,
                                                         "END_CAP_STYLE":0,
                                                         "JOIN_STYLE":0,
                                                         "MITER_LIMIT":1,
                                                         "DISSOLVE":0,
                                                         "OUTPUT": 'memory:'})
                                                         #"OUTPUT": 'postgres: table="public"."testpep" (geom) '+uri2.connectionInfo()})
        
        result_buffer_dissolve = processing.run('native:dissolve', {"INPUT": result_buffer['OUTPUT'],
                                                                    "FIELD": 'id',
                                                                    "OUTPUT": 'memory:'})
        
        buffer_dissolved = processing.run('native:dissolve', {"INPUT": result_buffer['OUTPUT'],
                                                             "OUTPUT": 'memory:'})        
        
        return result_buffer_dissolve,result_dissolve,buffer_dissolved

    def calcul_graf_valhalla(self,sql_punts):
        print("valhalla")

        crs_desti = QgsCoordinateReferenceSystem('EPSG:4326')
        crs_origen = QgsProject.instance().crs()
        transform_context = QgsProject.instance().transformContext()
        coord_transformer = QgsCoordinateTransform(crs_origen, crs_desti, transform_context)
        coordenades = []
        isocrones = []
        carrers = []
        for feature in sql_punts.getFeatures():
            geometry = feature.geometry()
            punt_id = feature['id']
            if geometry is not None and not geometry.isMultipart():
                point = geometry.asPoint()
                point_wgs84 = coord_transformer.transform(point)
                lon = point_wgs84.x()
                lat = point_wgs84.y()
                coordenades.append((f"{lon},{lat}", punt_id))
        if self.dlg.RB_Graf.isChecked():
            if self.dlg.comboMetodeTreball_Valhalla.currentText() == 'Distancia':
                range_type = 'distance'
                range = self.dlg.TL_Dist_Cost_Valhalla.text()
            if self.dlg.comboMetodeTreball_Valhalla.currentText() == 'Temps':
                range_type = 'time'
                #range = str(int(self.dlg.TL_Dist_Cost_Valhalla.text())*60)
                range = self.dlg.TL_Dist_Cost_Valhalla.text()

        if self.dlg.combo_cost_Valhalla.currentText() == 'Vianant':
            go = 'pedestrian'
        elif self.dlg.combo_cost_Valhalla.currentText() == 'Bicicleta':
            go = 'bicycle'
        elif self.dlg.combo_cost_Valhalla.currentText() == 'Cotxe':
            go = 'auto'
        else:
            QMessageBox.information(None, 'Informació:', 'No hi ha cap element seleccionat')
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()
            self.dlg.setEnabled(True)
            return

        for coordenada, punt_id in coordenades:
            params = {
                "mode": "valhalla",
                "service": "isochrone",
                "go": go,
                "orig": coordenada,
                "metric": range_type,
                "range": range,
                "polygons": "true",
                "reverse": str(not(self.dlg.checkReverse_VAL.isChecked())).lower()
            }
            response = requests.get(valhalla_base_url, params=params)
            print (response.url)

            if response.status_code == 200:
                try:
                    result_iso = response.json()
                except ValueError:
                    print("La resposta del servidor Valhalla no és un JSON vàlid. Resposta rebuda: ", response.text)
                    return
                geojson_data = result_iso
                crs_projecte = QgsProject.instance().crs().authid()
                layer = QgsVectorLayer(f"Polygon?crs={crs_projecte}", "Isocrona Valhalla", "memory")
                prov = layer.dataProvider()
                prov.addAttributes([QgsField("contour", QVariant.Int)])
                prov.addAttributes([QgsField("entity_id", QVariant.Int)])
                layer.updateFields()
                crs_origen = QgsCoordinateReferenceSystem('EPSG:4326')
                crs_desti = QgsProject.instance().crs()
                transform_context = QgsProject.instance().transformContext()
                coord_transformer = QgsCoordinateTransform(crs_origen, crs_desti, transform_context)
                '''
                for feature_data in geojson_data["features"]:
                    coordinates = feature_data["geometry"]["coordinates"][0]
                    contour_value = feature_data["properties"]["contour"]
                    transformed_coords = [coord_transformer.transform(QgsPointXY(lon, lat)) for lon, lat in coordinates]
                    polygon = QgsGeometry.fromPolygonXY([transformed_coords])
                    feature = QgsFeature()
                    feature.setGeometry(polygon)
                    feature.setAttributes([contour_value, punt_id])
                    prov.addFeatures([feature])
                isocrones.append(layer)
                '''
                for feature_data in geojson_data["features"]:
                    coordinates = feature_data['geometry']['coordinates']
                    geom_type = feature_data['geometry']['type']
                    contour_value = feature_data['properties']['contour']
                    if geom_type == 'Polygon':
                        rings = [coordinates[0]]
                    elif geom_type == 'MultiPolygon':
                        rings = [polygon[0] for polygon in coordinates]
                    else:
                        print(f"Error: geometria no reconeguda: {geom_type}")
                        return
                    
                    for ring in rings:
                        try:
                            transformed_coords = [
                                coord_transformer.transform(QgsPointXY(lon, lat)) for lon, lat in ring
                            ]
                        except Exception as e:
                            print(f"Error al transformar les coordenades: {e}")
                            continue
                    
                    if not transformed_coords or len(transformed_coords) < 3:
                        print("Error: polígon no vàlid")
                        continue
                    polygon = QgsGeometry.fromPolygonXY([transformed_coords])
                    feature = QgsFeature()
                    feature.setGeometry(polygon)
                    feature.setAttributes([contour_value, punt_id])
                    prov.addFeatures([feature])
                    QApplication.processEvents()
                isocrones.append(layer)
            else:
                print(f"Error a la solicitud al servidor Valhalla: {response.status_code}")
                print(response.text)
                return

        if len(isocrones) > 0:
            alg_params = {
                'LAYERS': isocrones,
                'CRS': f'{crs_projecte}',
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            result_iso = processing.run('native:mergevectorlayers', alg_params)['OUTPUT']
            result_iso.setName("Isocrones Valhalla Unides")
            #QgsProject.instance().addMapLayer(result_iso)
        else:
            print("No s'han trobat capes d'isocrones de Valhalla per unir")
            return

        # Es carrega la capa de la xarxa de carrers
        #uri2.setDataSource("","("+sql_xarxa+")","geom","","id")
        #network_lyr = QgsVectorLayer(uri2.uri(False), "xarxa", "postgres")
        #network_lyr = sql_xarxa

        for coordenada, punt_id in coordenades:
            params = {
                "mode": "valhalla",
                "service": "expansion",
                "go": go,
                "orig": coordenada,
                "metric": range_type,
                "range": range,
                "polygons": "true",
                "reverse": str(not(self.dlg.checkReverse_VAL.isChecked())).lower()
            }
            response = requests.get(valhalla_base_url, params=params)
            print (response.url)
            if response.status_code == 200:
                try:
                    result_exp = response.json()
                except ValueError:
                    print("La resposta del servidor Valhalla no és un JSON vàlid. Resposta rebuda: ", response.text)
                    return
                geojson_data = result_exp
                crs_projecte = QgsProject.instance().crs().authid()
                layer = QgsVectorLayer(f"LineString?crs={crs_projecte}", "Graf Valhalla", "memory")
                prov = layer.dataProvider()
                prov.addAttributes([QgsField("entity_id", QVariant.Int)])
                layer.updateFields()
                crs_origen = QgsCoordinateReferenceSystem('EPSG:4326')
                crs_desti = QgsProject.instance().crs()
                transform_context = QgsProject.instance().transformContext()
                coord_transformer = QgsCoordinateTransform(crs_origen, crs_desti, transform_context)
                for feature_data in geojson_data["features"]:
                    coordinates = feature_data["geometry"]["coordinates"]
                    transformed_coords = [coord_transformer.transform(QgsPointXY(lon, lat)) for lon, lat in coordinates]
                    line = QgsGeometry.fromPolylineXY(transformed_coords)
                    feature = QgsFeature()
                    feature.setGeometry(line)
                    feature.setAttributes([punt_id])
                    prov.addFeatures([feature])

                carrers.append(layer)
            else:
                print(f"Error a la solicitud al servidor Valhalla: {response.status_code}")
                print(response.text)
                return
        
        if len(carrers) > 0:
            alg_params = {
                'LAYERS': carrers,
                'CRS': f'{crs_projecte}',
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            result_exp = processing.run('native:mergevectorlayers', alg_params)['OUTPUT']
            result_exp.setName("Carrers Valhalla Unides")
            #QgsProject.instance().addMapLayer(result_exp)
        else:
            print("No s'han trobat capes de carrers de Valhalla per unir")
            return

        network_lyr = result_exp

        # Intersecció
        alg_params = {
            "INPUT": network_lyr,
            "OVERLAY": result_iso,
            "OUTPUT": 'TEMPORARY_OUTPUT'
        }
        carrers_afectats = processing.run('native:intersection', alg_params)['OUTPUT']
        #QgsProject.instance().addMapLayer(carrers_afectats)
        # Buffer dels carrers afectats
        alg_params = {
            "INPUT": carrers_afectats,
            "DISTANCE": self.dlg.TL_radiZI.text(),
            "SEGMENTS": 5,
            "END_CAP_STYLE": 0,
            "JOIN_STYLE": 0,
            "MITER_LIMIT": 1,
            "DISSOLVE": False,
            "OUTPUT": 'TEMPORARY_OUTPUT'
        }
        buffer = processing.run('native:buffer', alg_params)['OUTPUT']

        # Dissolve del buffer
        alg_params = {
            "INPUT": buffer,
            "FIELD": 'entity_id',
            "OUTPUT": 'TEMPORARY_OUTPUT'
        }
        result_buffer = processing.run('native:dissolve', alg_params)['OUTPUT']

        return result_buffer, carrers_afectats
                
    def on_click_cbDibuix(self,state):
        """Aquesta funció controla l'aparen�a del checkBox que controla l'apartat de Dibuix"""
        if state != QtCore.Qt.Checked:
            self.dlg.lblColor.setEnabled(False)
            self.dlg.color.setEnabled(False)
            self.dlg.lblTras.setEnabled(False)
            self.dlg.comboTras.setEnabled(False)         
        else:
            self.dlg.lblColor.setEnabled(True)
            self.dlg.color.setEnabled(True)
            self.dlg.lblTras.setEnabled(True)
            self.dlg.comboTras.setEnabled(True)   

    def on_click_ColorArea(self):
        global micolorArea
        aux = QColorDialog.getColor()
        if aux.isValid():
            micolorArea = aux
        estilo='border:1px solid #000000; background-color: '+ micolorArea.name()
        self.dlg.colorArea.setStyleSheet(estilo)
        self.dlg.colorArea.setAutoFillBackground(True)
        pep=self.dlg.colorArea.palette().color(1)
        pass
    
    def on_click_Color(self):
        """Aquesta funci� obra un dialeg per poder triar el color del contorn de l'area que volem pintar. """
        global micolor
        aux = QColorDialog.getColor()
        if aux.isValid():
            micolor = aux
        estilo='border:1px solid #000000; background-color: '+ micolor.name()
        self.dlg.color.setStyleSheet(estilo)
        self.dlg.color.setAutoFillBackground(True)
        pep=self.dlg.color.palette().color(1)

        pass
    
    def on_click_ColorArea_CCU(self):
        """Aquesta funci� obra un dialeg per poder triar el color de l'area que volem pintar. """
        global micolorArea
        aux = QColorDialog.getColor()
        if aux.isValid():
            micolorArea = aux
        estilo='border:1px solid #000000; background-color: '+ micolorArea.name()
        self.dlg.colorArea.setStyleSheet(estilo)
        self.dlg.colorArea.setAutoFillBackground(True)
        pep=self.dlg.colorArea.palette().color(1)

        self.dlg.color_2.setStyleSheet(estilo)
        self.dlg.color_2.setAutoFillBackground(True)
        pep=self.dlg.color_2.palette().color(1)

        pass

    def on_click_ColorArea_Valhalla(self):
        """Aquesta funci� obrir� un dialeg per poder triar el color de l'�rea que volem pintar. """
        global micolorArea
        aux = QColorDialog.getColor()
        if aux.isValid():
            micolorArea = aux
        estilo='border:1px solid #000000; background-color: '+ micolorArea.name()
        self.dlg.colorArea.setStyleSheet(estilo)
        self.dlg.colorArea.setAutoFillBackground(True)
        pep=self.dlg.colorArea.palette().color(1)

        pass
    
    def on_click_MarcarIlles(self, clicked):
        """Aquesta funci� controla l'aparen�a del bot� Illes """
        if clicked:
            self.dlg.bt_ILLES.setStyleSheet('background-color: #7fff7f')
            self.dlg.bt_Parcel.setChecked(False)
            self.dlg.bt_Portals.setChecked(False)
        else:
            self.dlg.bt_ILLES.setChecked(False)
            self.dlg.bt_ILLES.setStyleSheet('background-color: rgb(227, 227, 227)')
            
    def on_click_MarcarParcel(self, clicked):
        """Aquesta funci� controla l'aparen�a del bot� Parceles """
        if clicked:
            self.dlg.bt_Parcel.setStyleSheet('background-color: #7fff7f')
            self.dlg.bt_ILLES.setChecked(False)
            self.dlg.bt_Portals.setChecked(False)
        else:
            self.dlg.bt_Parcel.setChecked(False)
            self.dlg.bt_Parcel.setStyleSheet('background-color: rgb(227, 227, 227)')
            
    def on_click_MarcarPortals(self, clicked):
        """Aquesta funci� controla l'aparen�a del bot� Portals """
        if clicked:
            self.dlg.bt_Portals.setStyleSheet('background-color: #7fff7f')
            self.dlg.bt_Parcel.setChecked(False)
            self.dlg.bt_ILLES.setChecked(False)
        else:
            self.dlg.bt_Portals.setChecked(False)
            self.dlg.bt_Portals.setStyleSheet('background-color: rgb(227, 227, 227)')
    
    def on_click_Cancelar(self):
        """Aquesta funci� tancar la finestra."""
        if connexioFeta:
            self.eliminaTaulesTemporals()
        self.dlg.close()
    
    def changeComboMetodeTreball_CCU(self):
        """Aquesta funci� controla el canvi d'opci� del comboBox del m�tode treball."""
        dist = 'Distancia'
        temps = 'Temps'
        nom_metode=self.dlg.comboMetodeTreball_CCU.currentText()
        if dist == nom_metode:
            self.dlg.chk_CostNusos_CCU.setEnabled(False)
            self.dlg.chk_CostInvers_CCU.setEnabled(False)
            self.dlg.checkReverse.setEnabled(False)
            self.dlg.RB_campFix.setText('Distància (m):')
            self.dlg.RB_campTaula.setText('Camp de la distància:')
            self.dlg.TL_Dist_Cost_CCU.setText("150")
            self.dlg.chk_calc_local_CCU.setVisible(True)
            
        else:
            self.dlg.chk_CostNusos_CCU.setEnabled(True)
            self.dlg.chk_CostInvers_CCU.setEnabled(True)
            self.dlg.checkReverse.setEnabled(True)
            self.dlg.RB_campFix.setText('Temps (minuts):')
            self.dlg.RB_campTaula.setText('Camp del temps:')
            self.dlg.TL_Dist_Cost_CCU.setText("2")
            self.dlg.chk_calc_local_CCU.setVisible(True)

    def changeComboMetodeTreball_Valhalla(self):
        """Aquesta funcio controla el canvi d'opcio del comboBox del metode treball."""
        dist = 'Distancia'
        temps = 'Temps'
        nom_metode=self.dlg.comboMetodeTreball_Valhalla.currentText()
        if dist == nom_metode:
            self.dlg.lbl_campFix_Valhalla.setText('Distància (m):')
            self.dlg.TL_Dist_Cost_Valhalla.setText("150")
        else:
            self.dlg.lbl_campFix_Valhalla.setText('Temps (minuts):')
            self.dlg.TL_Dist_Cost_Valhalla.setText("2")
    
    def estatInicial(self):
        """Aquesta funci� posa tots els elements de la interficie en el seu estat inicial."""
        global micolor
        global micolorArea
        global Versio_modul
        global TEMPORARY_PATH
        self.dlg.versio.setText(Versio_modul)
        micolor = QColor(255,0,0,255)
        micolorArea = QColor(0,255,255,255)
        self.dlg.TL_Dist_Cost_CCU.setText("150")
        self.dlg.TL_Dist_Cost_Valhalla.setText("150")
        self.dlg.TL_radiZI.setText("20")
        self.dlg.colorArea.setStyleSheet('border:1px solid #000000; background-color: #aaffff')
        self.dlg.color_2.setStyleSheet('border:1px solid #000000; background-color: #ff0000')
        self.dlg.color.setStyleSheet('border:1px solid #000000; background-color: #ff0000')
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #FFFFFF')
        self.dlg.lblNum.setText("")
        self.dlg.lblNum.setStyleSheet('border:1px solid #000000')
        self.dlg.lblHab.setStyleSheet('border:1px solid #000000; background-color: rgb(85, 170, 255)')
        self.changeComboMetodeTreball_CCU()
        self.changeComboMetodeTreball_Valhalla()    
        self.dlg.lblColor_CCU.setEnabled(False)
        self.dlg.color_2.setEnabled(False)
        self.dlg.lblTras.setEnabled(False)
        self.dlg.comboTras.setEnabled(False)
        self.dlg.lblEstatConn.setText('No connectat')
        self.dlg.checkBoxDibuix.setChecked(False)
        self.dlg.comboSelPunts.clear()
        self.dlg.comboLeyenda.clear()
        self.dlg.comboCapaPunts_CCU.clear()
        self.dlg.comboGraf.clear()
        self.dlg.bt_ILLES.setChecked(True)
        self.dlg.bt_Parcel.setChecked(False)
        self.dlg.bt_Portals.setChecked(False)
        self.dlg.TB_titol.setText("")
        self.dlg.gb_poblacio.setVisible(False)
        self.dlg.RB_campTaula.setText('Camp de la distància:')
        self.dlg.chk_CostNusos_CCU.setChecked(False)
        self.dlg.chk_CostInvers_CCU.setChecked(True)
        self.dlg.chk_poblacio.setChecked(False)
        self.dlg.comboMetodeTreball_CCU.setCurrentIndex(0)
        self.dlg.comboMetodeTreball_Valhalla.setCurrentIndex(0)
        self.dlg.comboTras.setCurrentIndex(0)
        self.dlg.comboCapaPunts_CCU.clear()
        self.dlg.bt_Parcel.setChecked(False)
        self.dlg.bt_Portals.setChecked(False)
        self.dlg.bt_ILLES.setChecked(False)
        self.dlg.checkBoxPoblacioNoAfectada.setChecked(False)
        self.dlg.Progres.setValue(0)
        self.dlg.Progres.setVisible(False)
        self.dlg.RB_campFix.setChecked(True)
        self.dlg.RB_campFix.setText('Distància (m):')
        self.dlg.lbl_campFix_Valhalla.setText('Distància (m):')
        self.dlg.RB_campTaula.setChecked(False)
        self.dlg.comboCapaPunts_CCU.setEnabled(False)
        self.dlg.chk_calc_local_CCU.setChecked(True)
        self.dlg.chk_calc_local_CCU.setVisible(True)
        self.dlg.tabServeiRouting.setCurrentIndex(0)
        self.dlg.checkReverse.setChecked(False)
        self.dlg.checkReverse_VAL.setChecked(False)
        self.dlg.setWindowIcon(QIcon(self.plugin_dir+'\icon.png'))
        QApplication.processEvents()
        self.dlg.setEnabled(True)
        
        if (os.name=='nt'):
            TEMPORARY_PATH=os.environ['TMP']
        else:
            TEMPORARY_PATH=os.environ['TMPDIR']
       
    def on_Change_ComboConn(self):
        """
        En el moment en que es modifica la opcio escollida 
        del combo o desplegable de les connexions,
        autom�ticament comprova si es pot establir
        connexi� amb la bbdd seleccionada.
        """
        global nomBD1
        global contra1
        global host1
        global port1
        global usuari1
        global schema
        global cur
        global conn
        global versio_db
        global connexioFeta
        s = QSettings()
        self.dlg.comboCapaPunts_CCU.clear()
        self.dlg.comboGraf.clear()
        select = 'Selecciona connexió'
        nom_conn=self.dlg.comboConnexio.currentText()
        if nom_conn != select:
            s.beginGroup("PostgreSQL/connections/"+nom_conn)
            currentKeys = s.childKeys()
            
            nomBD1 = s.value("database", "" )
            contra1 = s.value("password", "" )
            host1 = s.value("host", "" )
            port1 = s.value("port", "" )
            usuari1 = s.value("username", "" )
            schema= 'public'
            
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #ffff7f')
            self.dlg.lblEstatConn.setText('Connectant...')
            self.dlg.lblEstatConn.setAutoFillBackground(True)
            QApplication.processEvents()

            #Connexio
            nomBD = nomBD1.encode('ascii','ignore')
            usuari = usuari1.encode('ascii','ignore')
            servidor = host1.encode('ascii','ignore')     
            contrasenya = contra1.encode('ascii','ignore')
            try:
                estructura = "dbname='"+ nomBD.decode("utf-8") + "' user='" + usuari.decode("utf-8") +"' host='" + servidor.decode("utf-8") +"' password='" + contrasenya.decode("utf-8") + "'"# schema='"+schema+"'"
                conn = psycopg2.connect(estructura)
                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                self.dlg.lblEstatConn.setText('Connectat')
                cur = conn.cursor()
                self.detect_database_version()
                #sql = "select f_table_name from geometry_columns where type = 'POINT' and f_table_schema ='public' order by 1"
                sql = "select f_table_name from geometry_columns where type in ('LINESTRING','MULTILINESTRING','POINT','MULTIPOINT','POLYGON','MULTIPOLYGON') and f_table_schema ='public' and f_table_name NOT LIKE \'%ccu_temp%\' order by 1"
                #sql = "select f_table_name from geometry_columns where type in ('POINT','MULTIPOINT') and f_table_schema ='public' and f_table_name NOT LIKE \'%ccu_temp%\' order by 1"
                cur.execute(sql)
                llista = cur.fetchall()
                self.ompleCombos(self.dlg.comboSelPunts, llista, 'Selecciona una entitat', True)
                sql2 = "select f_table_name from geometry_columns where ((type = 'MULTILINESTRING' or type = 'LINESTRING') and f_table_schema ='public' and f_table_name NOT LIKE \'%ccu_temp%\') order by 1"
                cur.execute(sql2)
                llista2 = cur.fetchall()
                self.ompleCombos(self.dlg.comboGraf, llista2, 'Selecciona una entitat', True)
                
                self.cerca_elements_Leyenda()
                connexioFeta = True
            except Exception as ex:
                print ("I am unable to connect to the database")
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", "I am unable to connect to the database")
                self.eliminaTaulesCalcul(Fitxer)
                self.eliminaTaulesTemporals()
    
                self.bar.clearWidgets()
                self.dlg.Progres.setValue(0)
                self.dlg.Progres.setVisible(False)
                self.dlg.lblEstatConn.setText('Connectat')
                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                self.dlg.lblEstatConn.setText('Error: Hi ha algun camp erroni.')
                return
            
        else:
            self.dlg.lblEstatConn.setText('No connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #FFFFFF')
    
    def detect_database_version(self):
        global cur
        global conn
        global versio_db

        cur.execute("""
                    SELECT taula
                    FROM config
                    WHERE variable = 'versio';
                    """)
        versio_db = cur.fetchone()[0]

        ''' Primer caldria trobar els noms de les taules que farem servir '''

        cur.execute("""
                    SELECT taula
                    FROM config
                    WHERE variable = 'parceles';
                    """)
        nom_parcel = cur.fetchone()[0]

        cur.execute("""
                    SELECT taula
                    FROM config
                    WHERE variable = 'illes';
                    """)
        nom_illes = cur.fetchone()[0]

        cur.execute("""
                    SELECT taula
                    FROM config
                    WHERE variable = 'portals';
                    """)
        nom_portals = cur.fetchone()[0]

        if self.dlg.comboGraf.currentText() == 'Selecciona una entitat' or self.dlg.comboGraf.currentText() == '':
            cur.execute("""
                        SELECT taula
                        FROM config
                        WHERE variable = 'xarxa';
                        """)
            nom_xarxa = cur.fetchone()[0]
        else:
            nom_xarxa = self.dlg.comboGraf.currentText()

        if versio_db == '1.0':
            cur.execute(f"""
                        DROP TABLE IF EXISTS parcel_temp_{Fitxer};
                        CREATE TABLE parcel_temp_{Fitxer} (
                            id_parcel,
                            geom,
                            cadastral_reference
                        ) AS SELECT "id", "geom", "utm_total" FROM "{nom_parcel}";
                        """)
            conn.commit()
            cur.execute(f"""
                        DROP TABLE IF EXISTS zone_{Fitxer};
                        CREATE TABLE zone_{Fitxer} (
                            id_zone,
                            geom,
                            cadastral_zoning_reference
                        ) AS SELECT "id", "geom", "D_S_I" FROM "{nom_illes}";
                        """)
            conn.commit()
            cur.execute(f"""
                        DROP TABLE IF EXISTS address_{Fitxer};
                        CREATE TABLE address_{Fitxer} (
                            id_address,
                            geom,
                            cadastral_reference,
                            designator
                        ) AS SELECT id, geom, "REF_CADAST", "Carrer_Num_Bis" FROM "{nom_portals}";
                        """)
            conn.commit()
            cur.execute(f"""
                        DROP TABLE IF EXISTS stretch_{Fitxer};
                        CREATE TABLE stretch_{Fitxer} (
                            id,
                            cost,
                            reverse_cost,
                            semaphores,
                            total_cost_semaphore,
                            geom,
                            source,
                            target,
                            length,
                            direction,
                            slope_abs,
                            speed,
                            reverse_speed
                        ) AS SELECT "id", "cost", "reverse_cost", "Nombre_Semafors", "Cost_Total_Semafor_Tram", "the_geom", "source", "target", "LENGTH", "SENTIT", "PENDENT_ABS", "VELOCITAT_PS", "VELOCITAT_PS_INV" FROM "{nom_xarxa}";
                        """)
            conn.commit()
            cur.execute(f"""SELECT pgr_createTopology('stretch_{Fitxer}', 0.0001, 'geom', 'id', 'source', 'target', clean:='true');""")
            conn.commit()
        else:
            cur.execute(f"""DROP TABLE IF EXISTS parcel_temp_{Fitxer};
                            CREATE TABLE parcel_temp_{Fitxer} AS SELECT * FROM parcel;""")
            conn.commit()
            cur.execute(f"""DROP TABLE IF EXISTS zone_{Fitxer};
                            CREATE TABLE zone_{Fitxer} AS SELECT * FROM zone;""")
            conn.commit()
            cur.execute(f"""DROP TABLE IF EXISTS address_{Fitxer};
                            CREATE TABLE address_{Fitxer} AS SELECT * FROM address;""")
            conn.commit()
            cur.execute(f"""DROP TABLE IF EXISTS stretch_{Fitxer};
                            CREATE TABLE stretch_{Fitxer} AS SELECT * FROM stretch;""")
            conn.commit()
            cur.execute(f"""SELECT pgr_createTopology('stretch_{Fitxer}', 0.0001, 'geom', 'id', 'source', 'target', clean:='true');""")
            conn.commit()

    def eliminaTaulesTemporals(self):
        global versio_db
        global cur
        global conn
        global connexioFeta
        global Fitxer
        sql = f"DROP TABLE IF EXISTS address_{Fitxer};\n"
        sql += f"DROP TABLE IF EXISTS zone_{Fitxer};\n"
        sql += f"DROP TABLE IF EXISTS parcel_temp_{Fitxer};\n"
        sql += f"DROP TABLE IF EXISTS stretch_{Fitxer};\n"
        sql += f"DROP TABLE IF EXISTS stretch_{Fitxer}_vertices_pgr;\n"
        cur.execute(sql)
        conn.commit()
        connexioFeta = False

    def cerca_elements_Leyenda(self):
        if self.dlg.comboConnexio.currentText() != 'Selecciona connexió':
            try: #Accedir als elements de la llegenda que siguin de tipus punt.
                aux = []
                layers = QgsProject.instance().mapLayers().values()
                for layer in layers:
                    #print(layer.type())
                    if layer.type()==QgsMapLayer.VectorLayer:
                        #aux.append(layer.name())
                        if layer.wkbType() not in (QgsWkbTypes.NoGeometry,QgsWkbTypes.NullGeometry,QgsWkbTypes.Unknown,QgsWkbTypes.UnknownGeometry,QgsWkbTypes.GeometryCollectionM,QgsWkbTypes.GeometryCollectionZ,QgsWkbTypes.GeometryCollectionZM):
                            aux.append(layer.name())
                        
                self.ompleCombos(self.dlg.comboLeyenda, aux, 'Selecciona una entitat', True)
            except Exception as ex:
                missatge="Error al afegir els elements de la llegenda"
                print (missatge)
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", missatge)
                return
            
    def on_Change_TabWidget(self,i):
        #print(i)
        self.dlg.comboLeyenda.setCurrentIndex(0) 
        self.dlg.comboSelPunts.setCurrentIndex(0) 
        tipus_entitat_punt=False
    def on_Change_ComboLeyenda(self):

        """
        En el moment en que es modifica la opcio escollida 
        del combo o desplegable de la capa de punts,
        automÃ ticament comprova els camps de la taula escollida.
        """
        global tipus_entitat_punt
        L_capa=self.dlg.comboLeyenda.currentText()  
             
        if L_capa == '' or L_capa == 'Selecciona una entitat':
            return False
        
        errors = self.controlEntitatLeyenda(L_capa) #retorna una llista amb aquells camps (id, geom, Nom) que no hi siguin.

        if len(errors) < 1:  # errors es una llista amb els camps que te la taula, si hi ha menys de 2, significa que falta algun camp.
            ErrorMessage = "La capa de destí seleccionada no es valida, necessita els camps (id, Nom). Li falten:\n"
            if "id" not in errors:
                ErrorMessage+= '\n-"id"\n'
            #if "geom" not in errors:
            #    ErrorMessage+= '\n-"geom"\n'
            #if "Nom" not in errors:
            #    ErrorMessage+= '\n-"Nom"\n'
            #if "NPlaces" not in errors:
            #    ErrorMessage+= '\n-"NPlaces"\n'
            
            QMessageBox.information(None, "Error", ErrorMessage+'\n')
            
            return False
    
        else:
            self.dlg.TB_titol.setText(L_capa)

            layers = QgsProject.instance().mapLayers().values()
            layer_selected=QgsProject.instance().mapLayersByName(L_capa)
            if (layer_selected[0].wkbType()==QgsWkbTypes.Point):
                tipus_entitat_punt=True
                self.dlg.RB_Graf.setEnabled(True)
                self.dlg.RB_Graf.setChecked(True)
            else:
                tipus_entitat_punt=False
                self.dlg.RB_RadiCirc.setChecked(True)
                self.dlg.RB_Graf.setEnabled(False)
            return True
    
    
    def tipus_entitat_escollida(self,entitat):
        global conn
        #conn = psycopg2.connect(estructura)
        cur = conn.cursor()
        sql = "select type from geometry_columns where f_table_name='"+entitat+"' and f_table_schema ='public' order by 1"
        cur.execute(sql)
        tipus = cur.fetchone()
        return tipus[0]

    def controlEntitatLeyenda(self,entitat):
        '''
        Aquest metode mira si la entitat rebuda te els camps (id, geom, name) retorna una llista amb aquells camps que hi siguin.
        '''
        global cur
        global conn
        list = []
        
        layers = QgsProject.instance().mapLayers().values()
        if layers != None:
            for layer in layers:
                if layer.type()==QgsMapLayer.VectorLayer:
                    if layer.sourceName() == entitat:
                        for each in layer.fields():
                            if each.name() == "id":
                                list.append("id")
                            #elif each.name() == "geom":
                            #    list.append("geom")
                            #elif each.name() == "name":
                            #    list.append("name")
        return list     
    
    
    def controlEntitatSelPunts(self,entitat):
        '''
        Aquest metode mira si la entitat rebuda te els camps (id, geom, name) retorna una llista amb aquells camps que no hi siguin.
        '''
        global cur
        global conn
        list = []
        
        try:
            select = "select column_name from information_schema.columns where table_name = \'"+entitat.replace("'", "''")+"\'"
            #print(select)
            cur.execute(select)
            auxlist = cur.fetchall()

            for x in range (len(auxlist)):
                #print(auxlist[x][0])
                if(auxlist[x][0]=="id"):
                    if "id" not in list:
                        list.append("id")
                #elif(auxlist[x][0]=="geom"):
                #    if "geom" not in list:
                #        list.append("geom")
                #elif(auxlist[x][0]=="name"):
                #    if "name" not in list:
                #        list.append("name")
            del auxlist[:]
            
            return list
        except Exception as ex:
            print ("SELECT column_name ERROR")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "SELECT column_name ERROR")
            return
    
    
    def on_Change_ComboSelPunts(self):#parameter (state)
        """
        En el moment en que es modifica la opcio escollida 
        del combo o desplegable de la capa de punts,
        automÃ ticament comprova els camps de la taula escollida.
        """
        global tipus_entitat_punt
        capa=self.dlg.comboSelPunts.currentText()  
             
        if capa == '' or capa == 'Selecciona una entitat':
            return
            
        errors = self.controlEntitatSelPunts(capa) #retorna una llista amb aquells camps (id, geom, name) que no hi siguin.

        if len(errors) < 1:  # errors es una llista amb els camps que te la taula, si hi ha menys de 2, significa que falta algun camp.
            ErrorMessage = "La capa de destí seleccionada no es valida, necessita els camps (id, name). Li falten:\n"
            if "id" not in errors:
                ErrorMessage+= '\n-"id"\n'
            #if "geom" not in errors:
            #    ErrorMessage+= '\n-"geom"\n'
            #if "name" not in errors:
            #    ErrorMessage+= '\n-"name"\n'
            #if "available_places" not in errors:
            #    ErrorMessage+= '\n-"available_places"\n'
            
            QMessageBox.information(None, "Error", ErrorMessage+'\n')
            
            return False
    
        else:
            self.dlg.TB_titol.setText(capa)
            tipus=self.tipus_entitat_escollida(capa)
            if tipus in ('LINESTRING','MULTILINESTRING','POLYGON','MULTIPOLYGON'):
                #self.dlg.comboGraf.setEnabled(False)
                self.dlg.comboMetodeTreball_CCU.setCurrentIndex(0)
                self.dlg.comboMetodeTreball_CCU.setEnabled(False)
                tipus_entitat_punt=False
                self.dlg.RB_RadiCirc.setChecked(True)
                self.dlg.RB_Graf.setEnabled(False)
            else:
                tipus_entitat_punt=True
                self.dlg.RB_Graf.setEnabled(True)
                self.dlg.RB_Graf.setChecked(True)

            return True
        '''
        capa=self.dlg.comboSelPunts.currentText()
        if capa != 'Selecciona una entitat':
            self.dlg.TB_titol.setText(capa)
            llista = self.obteLlista("SELECT column_name FROM information_schema.columns WHERE table_schema = 'public' AND table_name   = '" + capa + "'")
            self.ompleCombos(self.dlg.comboCapaPunts_CCU, llista,'Selecciona un camp', True)
        else:
            self.dlg.TB_titol.setText("")
            self.dlg.comboCapaPunts_CCU.clear()
        '''
    def on_Change_ComboGraf(self, state):
        """
        En el moment en que es modifica la opcio escollida 
        del combo o desplegable de la capa de punts,
        autom�ticament comprova els camps de la taula escollida.
        """
        try:
            capa=self.dlg.comboGraf.currentText()
            if capa != "":
                if capa != 'Selecciona una entitat':
                    if (self.grafValid(capa)):
                        if versio_db == '1.0':
                            cur.execute(f"""
                            DROP TABLE IF EXISTS stretch_{Fitxer};
                            CREATE TABLE stretch_{Fitxer} (
                                id,
                                cost,
                                reverse_cost,
                                semaphores,
                                total_cost_semaphore,
                                geom,
                                source,
                                target,
                                length,
                                direction,
                                slope_abs,
                                speed,
                                reverse_speed
                            ) AS SELECT "id", "cost", "reverse_cost", "Nombre_Semafors", "Cost_Total_Semafor_Tram", "the_geom", "source", "target", "LENGTH", "SENTIT", "PENDENT_ABS", "VELOCITAT_PS", "VELOCITAT_PS_INV" FROM "{capa}";
                            """)
                            conn.commit()
                            cur.execute(f"""SELECT pgr_createTopology('stretch_{Fitxer}', 0.0001, 'geom', 'id', 'source', 'target', clean:='true');""")
                            conn.commit()
                        else:
                            pass
                    else:
                        QMessageBox.information(None, "Error", "El graf seleccionat no té la capa de nusos corresponent.\nEscolliu un altre.")

        except Exception as ex:
            print ("Error Graf seleccionat")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error Graf seleccionat")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.eliminaTaulesTemporals()
            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
            return
        
    def on_Change_TabServeiRouting(self):
        if self.dlg.tabServeiRouting.currentIndex() == 0:
            self.dlg.comboGraf.setEnabled(True)
        else:
            self.dlg.comboGraf.setEnabled(False)

    def on_click_CB_poblacio(self, state):
        """Aquesta funci� mostra les funcions de dibuix en funci� de l'estat del checkBox"""
        if state != QtCore.Qt.Checked:
            self.dlg.gb_poblacio.setVisible(False)
        else:
            self.dlg.gb_poblacio.setVisible(True)
            
        
    def obteLlista(self, sql):
        """Aquesta funció obté llistes d'elements de la taula i les 
        retorna a altres funciones que les mostraran en pantalla."""
        global cur
        global conn
        llista = None
        cur.execute(sql)
        llista = cur.fetchall()
        return llista
        
    def campGeometria(self, taula):
        """Aquesta funció retorna el camp de geometria de la taula que li passem per parametres"""

        global cur
        global conn

        sql = f"select f_geometry_column from geometry_columns where f_table_name = '{taula}'"
        
        cur.execute(sql)
        camp = cur.fetchall()
        return camp[0][0]
        
    
    def populateComboBox(self,combo,list,predef,sort):
        """Procediment per omplir el combo especificat amb la llista suministrada"""
        combo.blockSignals (True)
        combo.clear()
        model=QStandardItemModel(combo)
        predefInList = None
        for elem in list:
            try:
                item = QStandardItem(str(elem))
            except TypeError:
                item = QStandardItem(str(elem))
            model.appendRow(item)
            if elem == predef:
                predefInList = elem
        if sort:
            model.sort(0)
        combo.setModel(model)
        if predef != "":
            if predefInList:
                combo.setCurrentIndex(combo.findText(predefInList))
            else:
                combo.insertItem(0,predef)
                combo.setCurrentIndex(0)
        combo.blockSignals (False)
    
    def ompleCombos(self, combo, llista, predef, sort):
        """Aquesta funci� omple els combos que li passem per par�metres"""
        combo.blockSignals (True)
        combo.clear()
        model=QStandardItemModel(combo)
        predefInList = None
        for elem in llista:
            try:
                if isinstance(elem, tuple):
                    item = QStandardItem(str(elem[0]))
                else:
                    item = QStandardItem(str(elem))
            except TypeError:
                item = QStandardItem(str(elem[0]))
            model.appendRow(item)
            if elem == predef:
                predefInList = elem
        combo.setModel(model)
        if predef != "":
            if predefInList:
                combo.setCurrentIndex(combo.findText(predefInList))
            else:
                combo.insertItem(0,predef)
                combo.setCurrentIndex(0)
        combo.blockSignals (False)
    
    def getConnections(self):
        """Aquesta funcio retorna les connexions que estan guardades en el projecte."""
        s = QSettings() 
        s.beginGroup("PostgreSQL/connections")
        currentConnections = s.childGroups()
        s.endGroup()
        return currentConnections

    def run(self):
        global Fitxer
        """Run method that performs all the real work"""
        # show the dialog
        self.estatInicial()
        self.dlg.show()
        conn=self.getConnections()
        #layers = QgsMapLayerRegistry.instance().mapLayers().values()
        self.populateComboBox(self.dlg.comboConnexio ,conn,'Selecciona connexió',True)
        
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass